Previous Interview question and answers

1. Tell me about yourself and your journey into front-end development.

I am a core UI Developer with 12+ years of experience building .com websites for different organizations using HTML5, CSS3, JavaScript, Angular 18, React.js, and Redux.
In the past 2 years, I worked on the React migration team, where I converted the .net pages to react on united.com.
Frontend is React, and used ATMOS (Own library) components used company wide.

Worked on Security features for users where they can manage there account like Forgot password, Forgot MileagePlus number,
security questions, Sign-in features, Miles-Pooling, United Club pass, Recent Activity, dashboard updates and
KTN(Known Traveler Number), Accessibility guidelines features on united.com.

used middleware such as redux-saga to handle asynchronous tasks such as API calls, data fetching, and impure actions in a more organized and efficient way.

Previously worked with Accelerator team for Visa Inc. remediation of MBDA modules like Application Management, Account Management, Portfolio Management, Analytics, Recurring billing, Virtual Terminal, etc for bank users like Wells Fargo, Bank of America, etc

Capital Group worked on DAVIS Project. Davis stands for Data visualization where we build different highcharts using react and integrate into the AEM., the backend is Java. Previously I worked on Creative Workbench, a writing tool where articles are published on capital group websites.

At Cerner Corporation worked on the medical examination forms.

In Office Depot worked on black Friday reporting.

Satinos Technologies created a tax portal and a schoomin website for the Vignan schools.

2. Walk me through your latest project – what problems did you solve?

React migration - Converted pages in .net to react.
The new initiative worked on Miles-Pooling( points you get after traveling), TSA Precheck, Account security and management features, and Under18.

3. How does the virtual DOM work in React?

Suppose line of code is changed , processing is done on particular line.
It will process the whole code in real DOM. Virtual DOM is faster.

4. What’s the difference between props and state in React?

Props (short for "properties") are read-only and passed from a parent component to a child component.
They allow components to communicate by passing data down the component tree.
Since props are immutable within the receiving component, they cannot be changed by the component itself.

State, on the other hand, is mutable and managed within a component.
It represents data that can change over time due to user interactions or other factors.
A component's state can be updated using React's useState hook (in functional components) or
setState (in class components), causing the component to re-render.

5. What is useEffect and how have you used it in your projects?

In React, useEffect is a hook that allows you to perform side effects in functional components.
Side effects include things like fetching data, updating the DOM, setting up subscriptions, and cleaning up resources.

How useEffect Works:
useEffect runs after the component renders.

It can be configured to run only once, on every render, or when specific values change.

You can return a function inside useEffect to clean up resources (like removing event listeners or unsubscribing from an API).

<!-- import { useEffect, useState } from "react";

function ExampleComponent() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(`Count changed to ${count}`);

    return () => {
      console.log("Cleanup before next useEffect runs or component unmounts");
    };
  }, [count]); // Runs whenever "count" changes

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
} -->

How I've Used useEffect in Projects:
Fetching Data: I’ve used useEffect to fetch API data when a component mounts ([] as the dependency array).

Listening to Window Events: Tracking things like window resizing or scroll position changes.

Setting Up Timers: Managing intervals and timeouts for features like countdown timers.

Cleaning Up Resources: Removing event listeners or stopping subscriptions when a component unmounts.

6. How do you manage API calls and error handling in React?

Ans: 1. Using Fetch or Axios for API Calls
You can make API requests using fetch or axios. Axios provides some extra features like automatic JSON parsing
and request cancellation.

    2. Using Axios for Cleaner Code
    3. Handling Errors Gracefully
    4. Using useEffect for API Calls
    5. Avoiding Memory Leaks

7. What’s the folder structure you prefer for a scalable front-end project?

A well-organized folder structure is crucial for scalability, maintainability, and readability in a front-end project. Here’s the structure I usually recommend for React-based projects (but it applies to other frameworks as well):

/project-root
├── public/ # Static assets (favicon, index.html)
├── src/ # Main source code
│ ├── assets/ # Images, fonts, global styles
│ ├── components/ # Reusable UI components
│ ├── pages/ # Individual pages/views
│ ├── hooks/ # Custom React hooks
│ ├── utils/ # Utility/helper functions
│ ├── services/ # API calls, authentication logic
│ ├── contexts/ # Global state management (Context API)
│ ├── styles/ # Global styles or component-specific styles
│ ├── store/ # State management (Redux, Zustand, etc.)
│ ├── config/ # Environment variables, app settings
│ ├── routes/ # Centralized route definitions
│ ├── tests/ # Unit & integration tests
│ ├── index.tsx # App entry point
│ ├── App.tsx # Root component
├── .env # Environment variables
├── package.json # Dependencies & scripts
├── tsconfig.json # TypeScript config (if using TypeScript)
├── README.md # Documentation

8. What is the role of Express.js in the MERN stack?

Express.js plays a crucial role in the MERN stack by acting as the backend framework that connects the front end (React) with the database (MongoDB) via Node.js.. Here's how it fits into the stack:

🚀 Role of Express.js in MERN:

1. Handles HTTP Requests & Routes

Express.js provides a simple and flexible way to define API routes (GET, POST, PUT, DELETE) that interact with the MongoDB database.

2. Middleware Integration

It allows middleware functions that handle authentication, logging, error handling, and request parsing (like body-parser).

3. Database Connectivity

Express.js interacts with MongoDB (usually via Mongoose) to perform CRUD operations efficiently.

4. Server-Side Logic & Business Rules

This is where backend logic is implemented—handling authentication, form validation, and access control.

5. API Development for Frontend Communication

The React front end makes API calls to Express.js, which then fetches or modifies data in MongoDB.

9. How do you optimize performance in a React app?

1. Memoization with useMemo and useCallback: Use this hooks to memoize values and, reducing unnecessary recalculations.
1. Optimizing Renders with React.Fragment: Use it to avoid unnecessary wrapper elements that could cause additional DOM nodes.
1. Lazy loading with React.lazy: Use it to load components lazily, reducing the intial bundle size and imporving intial loading performance.
1. Code splitting: Employ code splitting to divide your application into smaller chunks that are loaded on demand, improving initial load times.
1. Optimizing Images and Assets: Compress and optimize images, use responsive images and leverage lazy loading for images to reduce network and rendering overhead.

1. Difference Between Flex and Grid
• Flexbox (Flex):
○ One-dimensional layout: Arranges elements in a row or column.
○ Ideal for simple layouts with horizontal or vertical alignment.
○ Responsive: Easily adapts to different screen sizes.
○ Great for navigation bars, footers, and single-dimensional content sections.
• CSS Grid (Grid):
○ Two-dimensional layout: Creates rows and columns for complex layouts.
○ Superior for intricate structures with precise positioning.
○ Responsive: Maintains flexibility across devices.
○ Perfect for dashboards, product listings, and multi-column layouts.
Visual Demonstration:
• Flex: Show a navigation bar with elements aligned horizontally.
• Grid: Display a product listing with items arranged in rows and columns.
Choosing Between Flex and Grid:
• For simple layouts or single-dimensional alignment, flexbox often suffices.
• For complex structures with precise positioning, opt for grid.
• They can even be combined for more versatile layouts.
Example (Code Snippet):
JavaScript
// Flexbox for a navigation bar
<nav style={{ display: 'flex', justifyContent: 'space-between' }}>
  <a href="#">Home</a>
  <a href="#">About</a>
  <a href="#">Contact</a>
</nav>
// Grid for a product listing
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))' }}>
  <div className="product">Product 1</div>
  <div className="product">Product 2</div>
  {/* More products... */}
</div>

1. getElementById vs. getElementByClass
   • getElementById:
   ○ Retrieves an element by its unique ID.
   ○ Faster when you know the exact ID.
   ○ Use for elements that should only appear once.
   • getElementsByClassName:
   ○ Returns an array of elements with the same class name.
   ○ Useful when you have multiple elements with the same class.
   ○ Can be less performant for large numbers of elements.
   Choosing Between getElementById and getElementByClass:
   • Use getElementById for elements with a unique ID.
   • Use getElementsByClassName for multiple elements with the same class.
   Example (Code Snippet):
   JavaScript
   const heading = document.getElementById('main-heading'); // Use for unique ID
   const buttons = document.getElementsByClassName('btn'); // Use for multiple buttons
   Use code with caution.

1. What are ES6 Features ?


    • Arrow Functions: Concise syntax for defining functions.

JavaScript
const greet = name => `Hello, ${name}!`;

    • Template Literals: Embedded expressions within strings for dynamic content.

JavaScript
const message = `Welcome, ${user.name}`;

    • Destructuring: Extract properties from objects or arrays.

JavaScript
const { firstName, lastName } = user;

    • Classes: Object-oriented programming with inheritance.

JavaScript
class Person {
constructor(name) {
this.name = name;
}

greet() {
console.log(`Hello, I'm ${this.name}`);
}
}

    • Modules: Organize code in reusable modules.

JavaScript
// myModule.js
export function add(a, b) {
return a + b;
}

// main.js
import { add } from './myModule.js';
console.log(add(2, 3));

13. What are promises ?


    • Promises: Represent the eventual completion (or failure) of an asynchronous operation.
    • Benefits:
    	○ Improved code readability and maintainability by handling asynchronous operations asynchronously.
    	○ Chaining of asynchronous operations for a more fluid flow.
    	○ Error handling for potential issues during asynchronous execution.

Code Example (Using Fetch API):
JavaScript
fetch('https://api.example.com/data')
.then(response => response.json())
.then(data => {
console.log(data);
// Process the data
})
.catch(error => {
console.error(error);
// Handle errors
});

14. Redux is a state management library for JavaScript applications, including React. It provides a centralized store to hold application state, actions to update that state, and reducers to handle those updates.
    • Store: Holds the entire application state as a single JavaScript object tree.
    • Actions: Plain JavaScript objects describing the intention to change the state.
    • Reducers: Pure functions that accept the current state and an action, returning the new state.
    Dispatcher.
    Pros of Redux:
    • Predictable State Management: Easier to reason about application state and track changes.
    • Improved Testability: Easier to test components in isolation due to centralized state.
    • Scalability: Well-suited for large and complex applications.
    Cons of Redux:
    • Boilerplate Code: Requires setting up stores, reducers, actions, and middleware.
    • Complexity: Learning curve for managing state with reducers and actions.

15. Why Fetch Inside useEffect?
16. We typically fetch data inside useEffect in React because it ensures
    the data is fetched only when the component is mounted (or when
    dependencies in the array change).
17. This prevents unnecessary re-renders on every update and improves performance.
18. Additionally, useEffect allows for easy cleanup of side effects
    like subscriptions when the component unmounts.

19. What are props in Reactjs ?

Building Blocks of Communication
Imagine building Lego houses. Each Lego piece has properties that
define its color, size, and shape. Similarly, in React, props are
properties passed down from parent components to child components.
They act as a way for components to communicate and share data.
This allows you to create reusable and dynamic components!

17. What are different Component Types:

React offers two main types of components:

Class Components: These are like blueprints defining how a
component behaves and renders. They use the class keyword and
allow for functionalities like state management and lifecycle methods.
Structured way.

Functional Components: These are simpler and more concise.
They are pure functions that take props as input and return JSX
to describe what the component renders. They're a great choice
for presentational components.

18. What are states in ReactJS ?

Think of state as the internal memory of a component.
It allows components to react to user interactions or data changes.
You can use the useState hook to manage state in functional components.

19. What are stateless components in react ?

Stateless components, essentially functional components,
don't manage internal state. They simply take props as
input and return JSX based on those props. This makes
them lightweight and easier to reason about.

Example of a Stateless Component:

function Greeting(props) {
return (
<div>
<h1>Hello, {props.name}!</h1>
</div>
);
}

20. What are arrow functions in JS ?

Arrow functions (introduced in ES6) are a
concise way to write JavaScript functions.
They're often preferred for their cleaner syntax,
especially when dealing with props and state in React components.

Example of an Arrow Function:
JavaScript

const handleClick = () => {
console.log('Button clicked!');
};
handleClick()

21. What is redux ? and when to use it ?

Redux (although not strictly required for basic React applications)
is a popular state management library for managing complex application
state. It provides a centralized store to hold your application's state,
actions to update that state, and reducers to handle those updates.
(Think of it as a central bank for your app's data!)

22. What is JSX is reactjs ?

JSX (JavaScript XML) is a syntax extension that allows you to write
HTML-like structures within your JavaScript code. This makes
it easier to visualize and build user interfaces in React components.

Example of JSX:

return (

  <div>
    <h1>Welcome to My App</h1>
    <p>This is some content.</p>
  </div>
);

23. What is strict mode in JS

React's Strict Mode is a development tool that helps identify potential
issues in your application code. It enables warnings for deprecated
features, lifecycle methods, and other potential problems,
allowing you to catch them early during development.

---

HTML Interview questions

1. HTML5 new features vs HTML4?

Major New Features in HTML5:

Semantic tags: <article>, <section>, <header>, <footer>, <nav>, <main>, etc., for clearer document structure and better SEO.

Multimedia: <audio> and <video> tags allow native embedding of media without third-party plugins.

Graphics: <canvas> for 2D drawing and animation, plus improved SVG support.

Form controls: New input types (email, date, color, etc.), validation, and attributes like placeholder, required, and autofocus.

APIs: Geolocation, offline storage (local/session storage), drag-and-drop, Web Workers for background processing, and WebSockets for real-time communication.

Simplified syntax: Easier doctype and cleaner markup.

Improved accessibility and SEO: Semantic elements help search engines and assistive technologies understand content structure.

2. Storage in HTML?

1. Local Storage (localStorage)

Stores data permanently until manually cleared.

Data is saved across page reloads and browser sessions.

Example:
localStorage.setItem("username", "Vijay");
console.log(localStorage.getItem("username")); // Output: Vijay

2. Session Storage (sessionStorage)

Stores data temporarily (only until the browser tab is closed).

Example:
sessionStorage.setItem("theme", "dark");
console.log(sessionStorage.getItem("theme")); // Output: dark

3. Cookies (document.cookie)

Used for small amounts of data, typically for tracking user sessions.

Sent to the server with each request.

Example:
document.cookie = "username=Vijay; expires=Fri, 31 Dec 2025 23:59:59 GMT";

4. IndexedDB

A powerful NoSQL database inside the browser.

Supports complex data storage, including objects.

Example:

let db;
const request = indexedDB.open("myDatabase", 1);
request.onsuccess = () => { db = request.result; console.log("Database opened successfully"); };

5. Cache API (Service Workers)

Used for storing resources like files, images, and responses for offline use.

Works well for Progressive Web Apps (PWAs).

Example:
caches.open("my-cache").then(cache => {
  cache.add("/index.html");
});



3. iframe HTML

<iframe>, short for inline frame, is an HTML element that lets you embed another document (webpage, video, map, etc.) 
inside the current webpage.

🚀 How <iframe> Works
An <iframe> allows you to load external content within a designated area on your site.

<iframe src="https://example.com" width="600" height="400"></iframe>

✅ Common Use Cases
Embedding YouTube videos, Google Maps, or third-party widgets.

Loading external pages without redirecting users.

Displaying ads or content from other sources.


4. HTML5 features

Semantic Elements

New elements like <section>, <article>, <header>, <footer>, and <nav> improve the structure and readability of web pages.

Multimedia Support

Native <audio> and <video> elements let you embed media without requiring third-party plugins like Flash.

Why HTML5 is Better?
✅ Eliminates dependency on external plugins 
✅ Enhances performance and SEO 
✅ Optimized for mobile-friendly websites 
✅ Enables interactive web applications


5. which video type support HTML5

✅ MP4 – Best for maximum compatibility across all browsers. 
✅ WebM – Optimized for the web with good compression and fast loading. 
✅ Ogg – Open-source, but less widely supported compared to MP4 and WebM.


6. Maximum heading tag size?
In HTML, heading tags range from <h1> to <h6>, with <h1> being the largest and <h6> being the smallest by default.


7. marque tag?
The <marquee> tag in HTML was used to create scrolling text or moving elements across a webpage. 
However, it's now deprecated and no longer recommended for use.

<marquee behavior="scroll" direction="left">This is moving text!</marquee>


8. DOM?
The DOM (Document Object Model) is a programming interface for web documents that represents the structure of an HTML or 
XML document as a tree-like hierarchy. 
It allows JavaScript to dynamically manipulate content, structure, and styles on a webpage.

🚀 Key Features of DOM

✅ Tree Structure Representation

The DOM represents an HTML page as a tree, where elements like <html>, <body>, and <div> are nodes.

✅ Dynamic Content Manipulation

Developers can use JavaScript to add, remove, and modify elements dynamically.

✅ Event Handling

The DOM enables event-driven programming, allowing interactions through events like clicks, key presses, and hovers.

✅ Cross-Browser Compatibility

Works across different browsers, ensuring uniform behavior of web pages.



9. CSS integrate type in React.js? external (index.css), internal, inline css

✅ Inline Styles – Uses JavaScript objects for styling. 
✅ CSS Stylesheets – Imports regular CSS files. 
✅ CSS Modules – Scoped styles to avoid global conflicts. 
✅ Styled Components – CSS-in-JS for dynamic styling. 
✅ Tailwind CSS – Utility-first approach with predefined classes.

React and JS Interview questions:

1. what is shouldComponentUpdate?

shouldComponentUpdate() is used to optimize performance by preventing unnecessary re-renders. 
It returns true (default) to allow rendering or false to block it.

Ex: 
shouldComponentUpdate(nextProps, nextState) {
  return nextProps.value !== this.props.value; // Only update if "value" changes
}

✅ Helps with performance optimization 
✅ Mainly used in class components (functional components use React.memo) 
✅ Not required unless optimizing complex UI updates

2. pure component?

A Pure Component in React is a class component that automatically implements shouldComponentUpdate() with a shallow prop 
and state comparison to prevent unnecessary re-renders.

Ex: import React, { PureComponent } from "react";

class MyComponent extends PureComponent {
  render() {
    return <h1>Hello, Pure Component!</h1>;
  }
}


3. Local Storage (syntax) vs session storage vs cookies


Syntax Examples
1️⃣ Local Storage (Stores data permanently)

localStorage.setItem("username", "Vijay"); // Set item
console.log(localStorage.getItem("username")); // Get item
localStorage.removeItem("username"); // Remove item

2️⃣ Session Storage (Clears when tab is closed)
sessionStorage.setItem("theme", "dark"); // Set item
console.log(sessionStorage.getItem("theme")); // Get item
sessionStorage.clear(); // Clear all items

3️⃣ Cookies (Stores small data, sent with HTTP requests)
document.cookie = "username=Vijay; expires=Fri, 31 Dec 2025 23:59:59 GMT; path=/";
console.log(document.cookie); // Get all cookies


4. size of local storage
The size limit for Local Storage in most modern browsers is around 5MB per domain. 
This means each website can store up to 5MB of data in Local Storage.

5. context in react js syntax?
In React.js, Context API allows you to manage global state without passing props manually at every level.

🚀 Syntax Example
1️⃣ Create Context:
const MyContext = React.createContext();
2️⃣ Provide Context:
<MyContext.Provider value={sharedData}>
  <ChildComponent />
</MyContext.Provider>

3️⃣ Consume Context:
const value = useContext(MyContext);

✅ Helps avoid prop drilling 
✅ Ideal for theme, authentication, and global state 
❌ Not a replacement for complex state management like Redux

6. es6 features

ES6 introduced powerful features for modern JavaScript development: 
✅ let & const – Block-scoped variable declarations. 
✅ Arrow functions – Shorter function syntax (()=>{}).
✅ Template literals – ${variable} inside backticks for dynamic strings. 
✅ Destructuring – Easy extraction of object/array properties. 
✅ Spread & Rest (...) – Expands or collects elements flexibly. 
✅ Default parameters – Assign default values in functions. 
✅ Classes – Simplified object-oriented programming. 
✅ Modules (import/export) – Enables modular code structure. 
✅ Promises – Handles asynchronous operations (then/catch). 
✅ Map & Set – New data structures for unique values and fast lookups.



7. why we use promises?

We use Promises in JavaScript to handle asynchronous operations efficiently. 
They help avoid callback hell and make code more readable by using .then() and .catch() for handling success and errors.

✅ Improves readability – Avoids nested callbacks 
✅ Handles async operations – Fetch API, database queries, timers 
✅ Error handling – .catch() method simplifies error management 
✅ Chaining support – .then() allows sequential execution

Ex:
fetch("https://api.example.com/data")
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error("Error:", error));


8. virtual DOM?

The Virtual DOM is a lightweight copy of the actual DOM that React uses to improve performance.

✅ Fast Updates – React updates the Virtual DOM first, then efficiently syncs with the real DOM. 
✅ Minimizes Re-renders – Uses diffing to update only necessary elements, avoiding full page refreshes. 
✅ Enhances Performance – Reduces direct manipulations of the real DOM, improving speed.

Example process: 
1️⃣ React updates Virtual DOM. 
2️⃣ It compares changes (diffing). 
3️⃣ Only necessary updates are applied to the real DOM.

9. props drilling?

Props drilling occurs when data (props) is passed deeply through multiple nested components in React, even when some components don’t need it.

✅ Problem: Makes code harder to manage in large applications. 
✅ Solution: Use Context API or state management (Redux, Zustand, etc.) to avoid unnecessary prop passing.


10. webpacks uses why? 

Webpack is a powerful JavaScript module bundler used to optimize and manage assets in web applications.

✅ Bundles & Minifies – Combines multiple files into one, reducing load time. 
✅ Code Splitting – Loads only necessary code for better performance. 
✅ Asset Management – Handles CSS, images, and fonts efficiently. 
✅ Hot Module Replacement – Allows real-time updates during development. 
✅ Tree Shaking – Removes unused code for a smaller bundle size.


11. without npm project will run?

Yes, a JavaScript project can run without npm, but it depends on how dependencies are managed.

🔥 Explanation:
Pure JavaScript Projects (Vanilla JS) can run without npm if dependencies are manually included via CDN or local files.

Node.js Applications may require npm for package management, but can use manual installation or alternative package managers like Yarn or PNPM.

React, Vue, or Angular Projects typically rely on npm for dependencies and won't run properly without a package manager.


12. how to start rendering in react.js project

🚀 Basic Steps to Start Rendering
✅ Import React and ReactDOM:
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";


✅ Use ReactDOM.createRoot() (React 18+):
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);

✅ Ensure the root div exists in index.html:
<div id="root"></div>

This initializes the React app and renders the App component inside the root element.

13. how react code will get executed?

React code executes in the following steps:

✅ JSX Compilation – JSX is transformed into JavaScript using Babel. 
✅ Component Rendering – React creates the Virtual DOM. 
✅ Reconciliation – React compares Virtual DOM changes with the real DOM. 
✅ DOM Updates – React efficiently updates only necessary elements. 
✅ Event Handling – React listens for user interactions via synthetic events.


14. how to achieve optimization? 

React.js optimization can be achieved through several techniques:

✅ Use React.memo – Prevents unnecessary re-renders for functional components. 
✅ Use useCallback & useMemo – Optimizes function and value memoization. 
✅ Code Splitting – Load only required components using React.lazy & Suspense. 
✅ Avoid unnecessary state updates – Keep components minimal and optimize re-renders. 
✅ Virtualization – Improve performance for large lists with react-window. 
✅ Efficient rendering – Use key props correctly to avoid unwanted re-renders. 
✅ Avoid props drilling – Use Context API or Redux for state management.


15. difference between normal reducer and useReducer

✅ Normal Reducer – A function that manages state updates, typically used in Redux for global state management. 
✅ useReducer – A React hook that manages local component state using a reducer function, useful for complex state logic inside components.

Key Differences:

Normal Reducer works globally via Redux, while useReducer is for local component state.

useReducer is a React Hook, does not require Redux setup.

Redux Reducers use dispatch(actions), while useReducer relies on dispatch within the component.


16. class vs className

In HTML, class is an attribute used to define a CSS class for styling elements. 
In React (JSX), className is used instead of class, because class is a reserved keyword in JavaScript.

✅ HTML Example:
<div class="container">Hello</div>

✅ React Example:
<div className="container">Hello</div>


17. React Native

React Native is a framework for building mobile applications using React and JavaScript.

✅ Cross-platform – Develop once, run on both iOS & Android. 
✅ Uses JavaScript & JSX – Write mobile apps using familiar React syntax. 
✅ Native Performance – Renders UI components using native platform APIs. 
✅ Reusable Components – Share code between mobile and web applications. 
✅ Popular for mobile development – Used by apps like Instagram, Facebook, and Airbnb.

18. how many ways there to create react native app

You can create a React Native app in three main ways:

✅ Expo CLI – Easiest way, requires minimal setup (npx create-expo-app myApp). 
✅ React Native CLI – More customizable, allows direct access to native code (npx react-native init myApp). 
✅ Third-party tools – Tools like Ignite or ReNative for advanced setups.

19. redux saga (put, call, every)

Redux Saga is a middleware for handling side effects (like async API calls) in Redux using generator functions.

✅ put() – Dispatches an action to the Redux store. 
✅ call() – Calls a function (like an API request) and waits for the result. 
✅ takeEvery() – Listens for every occurrence of an action and runs a saga.

Example:
function* fetchDataSaga() {
  const data = yield call(api.getData);
  yield put({ type: "DATA_SUCCESS", payload: data });
}

function* watchFetchData() {
  yield takeEvery("FETCH_DATA", fetchDataSaga);
}


20. redux without api call

✅ Yes! Redux can manage state without API calls.

🚀 Use Cases Without API Calls:

UI State Management – Toggle dark mode, modal visibility.

Local Data Handling – Manage form inputs across components.

Client-Side Caching – Store temporary data for better performance.

Static Data Flow – Predefined data for UI updates.

Example without API calls:

const initialState = { count: 0 };

function counterReducer(state = initialState, action) {
  if (action.type === "INCREMENT") {
    return { count: state.count + 1 };
  }
  return state;
}


21. What is HOC? purpose?

A Higher-Order Component (HOC) in React is a function that takes a component as input and returns a new enhanced component.

✅ Purpose:

Code reusability – Share logic across multiple components.

Enhance components – Add additional functionality without modifying the original.

Example: Wrapping a component with authentication logic.

🚀 Example of HOC:

const withAuth = (Component) => (props) =>
  props.isAuthenticated ? <Component {...props} /> : <p>Please login</p>;


22. sort array without sort method, let arr = [1,5,7,2,3]

You can sort an array without using the sort() method by implementing a sorting algorithm manually, such as Bubble Sort or Insertion Sort.

🚀 Example: Bubble Sort
function bubbleSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // Swap values
      }
    }
  }
  return arr;
}

let arr = [1, 5, 7, 2, 3];
console.log(bubbleSort(arr)); // Output: [1, 2, 3, 5, 7]


23. closure? example
A closure in JavaScript is a function that remembers the variables from its outer scope even after the outer function has executed.

🔥 Example Closure Function
function outerFunction(x) {
  return function innerFunction(y) {
    return x + y; // `innerFunction` remembers `x` from `outerFunction`
  };
}

const add5 = outerFunction(5); 
console.log(add5(3)); // Output: 8

✅ Closure retains access to x even after outerFunction finishes. 
✅ Useful for encapsulation, maintaining private variables, and function factories.


24. let, var, const difference
In JavaScript, let, var, and const are used for variable declarations, but they differ in scope, mutability, and hoisting:

✅ var – Function-scoped, can be redeclared and updated, hoisted but uninitialized. 
✅ let – Block-scoped, cannot be redeclared, but can be updated, hoisted but uninitialized. 
✅ const – Block-scoped, cannot be reassigned or redeclared, must be initialized.

Ex: 
var a = 10; // Function-scoped
let b = 20; // Block-scoped
const c = 30; // Block-scoped, immutable

25. What is Hoisting?

Hoisting in JavaScript is the process where variable and function declarations are moved to the top of their scope before execution.

✅ Function hoisting – Allows calling a function before its declaration. 
✅ Variable hoisting – var is hoisted but initialized as undefined,
while let & const are hoisted but not initialized (cause errors if accessed before declaration).

temporal dead zone: it is zone where it belong.

26. function test(){
  var x = 10;
  var x;
  var x = 40;
  console.log("x is" + x);
}

test();
40

27. Explain the scope of temporal dead zone?
{
  //TDX starts
  const func = () => console.log(letVar);
  // TDZ
  let letVar = 3; // end TDZ
  func();
}

28. why var hoisiting is present in javascript?
var hoisting is present in JavaScript due to its interpreted nature and execution model.

🚀 Reasons for var Hoisting: 
✅ Historical Design Choice – JavaScript was originally designed for quick scripting, and var hoisting made it more flexible. 
✅ Function Execution Flexibility – Allows variables to be declared anywhere within a function but still accessible at the top. 
✅ Compilation Phase Handling – During execution, JavaScript hoists declarations (moves them to the top of their scope) before executing code.

29. Pure functions: Those functions that are deterministic in nature.

function areaofRectangle(length, width){
  return length * width;
}

areaofRectangle(10,20);
areaofRectangle(10,20);
areaofRectangle(10,30);
areaofRectangle(40,20);

30. Impure functions - those functions that are non-determinstic in nature.

function test(length, width){
  const temp = Math.floor(Math.random() * 10);
  return length * width * temp;
}
test(10, 20);

31. what is console.log('hello world') ; //logging , debugging.

console.log() is function.

32. shallow copy:  copy by reference

deep copy: copy by value

33. A shallow copy duplicates only the reference to nested objects, meaning changes to the copy affect the original. 
A deep copy creates an independent copy of all nested objects, ensuring no link to the original data.

🚀 Example in JavaScript: ✅ Shallow Copy (using Object.assign() or spread operator ...)
const obj1 = { name: "Vijay", details: { age: 30 } };
const shallowCopy = { ...obj1 }; 
shallowCopy.details.age = 35; 
console.log(obj1.details.age); // ❌ Changes original object (shallow copy)


✅ Deep Copy (using JSON.parse(JSON.stringify()) or structuredClone)

const obj2 = { name: "Vijay", details: { age: 30 } };
const deepCopy = JSON.parse(JSON.stringify(obj2)); 
deepCopy.details.age = 35; 
console.log(obj2.details.age); // ✅ Original remains unchanged (deep copy)


================================================

34. Can you provide an example of a complex React.js project you worked on and explain your role in its development?

In a recent project, I played a significant role in developing a complex React.js feature for a flight ticket booking system. 
One of the challenges involved resolving issues related to account setup. 
To tackle this, I utilized Postman to interact with multiple APIs and successfully unlock accounts, ensuring smooth user experience. 
I also documented this process for team reference, promoting efficiency and collaboration. Moreover, I have experience in managing weekly releases,
effectively addressing any backend blockers to maintain a seamless UI. 
his hands-on experience in addressing complex challenges showcases my ability to contribute effectively to React.js projects.

35. How do you ensure the scalability and performance optimization of React.js applications you work on?

In my React.js development work, I prioritize scalability and performance optimization by leveraging important tools and techniques. 
For instance, I implement the use of useMemo and useCallback hooks to efficiently memoize values and minimize recalculations. 
Additionally, I utilize code splitting and lazy loading to ensure that resources are loaded only when needed, enhancing the application's
overall performance. Moreover, I focus on optimizing assets and images to reduce load times. By strategically applying these methods, 
I have consistently improved the performance of React.js applications, ensuring a smooth and responsive user experience

36. In your opinion, what are the key differences between React.js functional components and class components, and when would you choose one over the other?

React.js provides two main types of components: functional components and class components. 
The key difference lies in their syntax and usage. 
Class components are defined as a class that extends the 'Component' class from React and uses lifecycle methods for actions like mounting, 
updating, and unmounting. On the other hand, functional components are implemented as plain JavaScript functions. 
With the introduction of hooks in React 16.8, functional components now support state management and side effects through hooks like useState, 
useEffect, useCallback, useRef, and useMemo. 
It's important to note that both types can be used effectively, but functional components are currently favored due to the simplicity and 
reusability offered by hooks. This allows for clearer and more concise code.

=======================================================================
Technical Round - 45 min to 1hr

1. ReactJS
2. JavaScript
3. CSS3
4. HTML5

ReactJS

1. Explain redux and its architecture

Redux is a state management library for JavaScript applications, often used with React to manage global state in a predictable way.

Redux Architecture:
Store – Holds the application’s state.

Action – A plain object that describes what happened (e.g., { type: 'INCREMENT' }).

Reducer – A pure function that takes the current state and an action, and returns a new state.

Dispatch – Sends actions to the store.

Subscriber – Components subscribe to the store to receive updates.

Data flow is unidirectional:
Component → Dispatch Action → Reducer → New State → UI Update

2. What is Virtual DOM and how does it work?

Virtual DOM is a lightweight copy of the real DOM. 
When the state changes, React creates a new Virtual DOM, compares it with the old one (diffing), and updates only 
the changed parts in the real DOM for better performance.

3. What is Reconciliation?

✅ Reconciliation – React compares Virtual DOM changes with the real DOM. 

4. Have you worked on class component or functional?

"Yes, I have experience working with both class and functional components in React. 
Initially, I used class components for state management and lifecycle methods, but with the introduction of hooks, 
I transitioned to functional components for their simplicity and reusability. 
Functional components, along with hooks like useState and useEffect, have allowed me to write cleaner, more maintainable code. 
While I can work with class components when needed, I primarily use functional components in newer projects to align with modern React practices.


5. what are hooks in react and why are they used?

Hooks in React are functions that let you use state and lifecycle features in functional components, without needing class components.

Why are they used?
Manage state: useState allows state management in functional components.

Side effects: useEffect handles data fetching, subscriptions, and other effects.

Performance optimization: useMemo and useCallback help prevent unnecessary re-renders.

Custom logic reuse: Custom hooks enable sharing logic across components.

6. how do you setup routing in react application?

Use React Router for routing:

Install it: npm install react-router-dom

Wrap the app in <BrowserRouter>

Use <Routes> and <Route> to define paths

Use <Link> for navigation

7. What technique can be used to optimize react application?

Optimizing a React app: 
Use React.memo, useCallback, and useMemo to prevent unnecessary re-renders. 
Apply lazy loading, code splitting, and virtualization for efficient rendering. 
Optimize state management, minimize useEffect dependencies, and use SSR/SSG for faster load times.

javascript
---------------
1. What is closure in Javascript? what is lexical scope?

Closure allows a function to remember and access its parent’s variables even after execution.

Lexical scope determines variable accessibility based on where functions are declared in the code.

2. what is hoisting in javascript? 

Hoisting is JavaScript's behavior of moving variable and function declarations to the top of their scope before execution. 

Functions are fully hoisted, while var variables are hoisted but remain undefined until assigned. 
let and const are hoisted but inaccessible until initialized.

3. what are callback, promises and async-await?

Callback: A function passed as an argument to another function, executed later. 

Promise: An object representing a pending, fulfilled, or rejected asynchronous operation. 

Async/Await: A way to write asynchronous code more cleanly, making it look synchronous. 

All three help manage async tasks like API calls and file handling.


4. what are the ES6 feature?

ES6 features:

Let & Const: Block-scoped variables.

Arrow Functions: Shorter function syntax (() =>).

Template Literals: String interpolation (${}) and multi-line strings.

Destructuring: Unpacking values from arrays/objects.

Default Parameters: Default values for function parameters.

Rest & Spread: Handle arrays/objects (...).

Classes: OOP syntax for creating classes.

Modules: import and export for modular code.

Promises: Asynchronous operations handling.

Iterators & Generators: Custom iteration with for...of and yield.



5. What is Event Loops in JS?

Event Loop in JavaScript is a mechanism that handles asynchronous operations. 
It allows the JavaScript engine to execute non-blocking code (like I/O operations) by using the call stack, callback queue, and event queue.

Call Stack: Where the functions are executed.

Callback Queue: Stores the callback functions that need to be executed after the call stack is clear.

Event Loop: Continuously checks if the call stack is empty, and if so, moves the first event from the callback queue to the stack for execution.

6. What is ES6 Array methods - map(), filter()

map(): Creates a new array by applying a function to each element of the original array.

const arr = [1, 2, 3];
const newArr = arr.map(x => x * 2); // [2, 4, 6]

filter(): Creates a new array with all elements that pass the condition in the provided function.

const arr = [1, 2, 3, 4];
const evenArr = arr.filter(x => x % 2 === 0); // [2, 4]




CSS3:

1. Explain the Box Model in CSS?

The CSS Box Model describes how elements are structured on a page. It includes:

Content – The actual text or image.

Padding – Space around the content.

Border – Wraps around the padding.

Margin – Space outside the border, separating elements.

2. What is difference between position Absolute & Relative?

position: relative moves an element relative to its normal position.
position: absolute removes the element from the normal flow and positions it relative to the nearest positioned ancestor.

3. What is the difference between rem and px?

px is an absolute unit — it defines a fixed size in pixels.
rem is a relative unit — it scales based on the root element’s (<html>) font size.

Example: If root font size is 16px, then 1rem = 16px.

4. What is Flex box?

Flexbox is a CSS layout model that makes it easy to align, space, and distribute items in a container, even when their size is unknown.

It uses properties like display: flex, justify-content, align-items, and flex-direction to create responsive layouts.

5. What is Grid Layout?

CSS Grid Layout is a 2D layout system used to design web pages in rows and columns.

It allows precise control over placement using properties like display: grid, grid-template-columns, grid-template-rows, and grid-gap.


HTML5:

1. What is Semantic Elements in HTML?
Semantic elements in HTML clearly describe their meaning to both the browser and developer.
Examples include <article>, <section>, <header>, and <footer>. They improve readability, accessibility, and SEO.

2. What is purpose of meta tag in HTML?

The meta tag in HTML provides metadata about the web page, such as character encoding, author, description, and 
viewport settings. It's mainly used for SEO and browser behavior control

3. What is block level and inline element?

Block-level elements take up the full width and start on a new line (e.g., <div>, <p>, <h1>).
Inline elements take up only as much width as needed and do not start on a new line (e.g., <span>, <a>, <strong>).


4. What is local storage vs Session Storage
Local Storage stores data with no expiration time — it persists even after the browser is closed.
Session Storage stores data only for the duration of the page session — it clears when the tab or browser is closed.

==========================================================================================================================

technical interview questions
-----------------------------------------

1. tell me about yourself?

2. which version of react.js are using? React v18.2.0

3. what is async await?
async and await are JavaScript keywords used to handle asynchronous operations in a cleaner, more readable way compared 
to traditional Promises and callbacks

"async/await is a syntax in JavaScript that makes it easier to work with Promises. 
async makes a function return a Promise, and await pauses execution until the Promise resolves, 
 asynchronous code to be written in a more readable, synchronous-like way."

4.  what is synchronous vs asychronous?

Synchronous code runs one task at a time, blocking the next task until the current one finishes.
Asynchronous code allows multiple tasks to run without waiting—like handling network requests—so the 
program stays responsive.

5. how to call multiple api calls simunatenously?
To make multiple API calls at the same time, I use Promise.all(). 
It takes an array of Promises and waits until all of them are resolved or any one fails.

async function fetchAllData() {
  const [userData, postsData] = await Promise.all([
    fetch('/api/user'),
    fetch('/api/posts')
  ]);

  const user = await userData.json();
  const posts = await postsData.json();

  console.log(user, posts);
}

// This runs both API calls at the same time and waits for both to complete.

6. what is controlled and uncontrolled components?

In React, controlled components are form elements whose values are managed by React state. 
Uncontrolled components manage their own state internally using the DOM, often accessed via ref.

Controlled: React is the single source of truth.

Uncontrolled: DOM handles the form data.

7. what is Debouncing ?

Debouncing is a technique used to limit how often a function is called.
It ensures the function runs only after a specified delay once the last event (like typing or scrolling) has stopped. 
It’s commonly used to optimize performance in search inputs, resize, or scroll events.

8. What is useEffect hook? How Does useEffect Work?

The useEffect hook in React is used to handle side effects in functional components, like data fetching, 
subscriptions, or manually changing the DOM. It runs after the component renders.

✅ How useEffect Works:


useEffect(() => {
  // Side effect logic here (e.g., API call)

  return () => {
    // Optional cleanup (e.g., clear timer, unsubscribe)
  };
}, [dependencies]);
The first argument is a function with your side effect logic.

The second argument is a dependency array that controls when the effect runs.



9. did you work on custom hooks?
Yes, I’ve worked with custom hooks in React to encapsulate reusable logic and keep components clean. 
For example, I created a custom hook for form handling, another for API data fetching with loading and error states, 
and one to manage debounced input values. This helped maintain separation of concerns and made my code more modular 
and testable.

10. how to make api call without useEffect?

You can make an API call without using useEffect by triggering it through user actions like a button click,
form submission, or any other event handler.

11. What is promise.All() and race?

Promise.all(): Waits for all Promises to resolve or for any to reject.

Promise.race(): Resolves or rejects as soon as one Promise resolves or rejects.


12. How do you integrate 2 API in front end with useEffect?
To integrate two APIs in the frontend using useEffect, 
you can either call them simultaneously with Promise.all() or sequentially.

Simultaneous: Both APIs are called in parallel.

Sequential: One API is called after the other.

13. How Do Uncontrolled Components Work?
Uncontrolled components in React manage their own state via the DOM, not React state. You access the values using refs.


14. redux architecture?

Redux architecture consists of three key parts:

Store: Holds the entire application state.

Actions: Plain objects that describe what happened.

Reducers: Functions that update the state based on the action.

Data Flow:
Actions are dispatched.

Reducers process the action and return a new state.

Store updates and re-renders subscribed components.


15. what is == vs ===? Which One Should You Use?

== (Loose Equality): Compares values after type coercion (converts the types before comparing).

=== (Strict Equality): Compares both value and type without type coercion.

Always use === for strict equality to avoid unexpected results from type coercion.

== should be avoided unless you specifically want type coercion.

16. can you explain your implementation

17. have you worked as a LEAD?


18. what is return and commit in JSX?

return in JSX is used to return the JSX that represents the UI in React components.

Example:

function MyComponent() {
  return <div>Hello</div>;
}
commit is not a standard React/JSX concept. 
It might refer to operations in third-party libraries or custom implementations, often related to finalizing changes 
or state updates.

19. What is map()? and reduce()?


map(): Creates a new array by applying a function to each element of the original array.

[1, 2, 3].map(num => num * 2); // [2, 4, 6]

reduce(): Accumulates a single value by applying a function to each element, with an accumulator.

[1, 2, 3].reduce((acc, num) => acc + num, 0); // 6


20. what is the output of map()?

The output of map() is a new array with transformed elements based on the function provided.

Example:
[1, 2, 3].map(num => num * 2); // [2, 4, 6]

====================================================================

30 minute interview

Senior React.js Developer Interview Question and Answers.

1. Tell me about yourself?


2. React Hooks: 
Hooks are functions that enable functional components to manage state and lifecycle features, 
providing a more concise and expressive way to handle component logic.

3. What are the popular hooks in react and explain it's usage?

useState: Manages state in functional components.
useEffect: Manages side effects in functional components.
useContext: Consumes context in functional components.
useReducer: Manage state with a reducer function, For More complex state management.
useRef: Accesses DOM elements or stores mutable values.
useCallback: performance improvement usecase
useMemo: performance improvement usecase.

4. How can you Optimize Performance in React application?
1. Memoization with useMemo and useCallback:  Use this hooks to memoize values and, reducing unnecessary recalculations.
2. Optimizing Renders with React.Fragment: Use it to avoid unnecessary wrapper elements that could cause additional DOM nodes.
3. Lazy loading with React.lazy: Use it to load components lazily, reducing the intial bundle size and imporving intial loading performance.
4. Code splitting: Employ code splitting to divide your application into smaller chunks that are loaded on demand, improving initial load times.
5. Optimizing Images and Assets:  Compress and optimize images, use responsive images and leverage lazy loading for images to reduce network and rendering overhead.


5.  Difference between virtual DOM and real DOM?
Suppose line of code is changed , processing is done on particular line. 
It will process the whole code in real DOM. Virtual DOM is faster.

6. Redux is a predictable state container for JavaScript applications. 
It helps to you write applications, run in different environments and easy to test. 
And simply we called as Redux is a state management tool.
Components in redux
Actions -->Input Parameters Ex: Deposit and Withdraw money from ATM
Store --> Main Server
Reducers --> Business Logic
Dispatch --> Request
Subscribe --> Response
State --> Store Component Data

7. What is state management in react application? 3rd party module, with redux.
Redux? We have redux thux, redux saga.
What is redux thunx, redux saga? Inorder to manipulate the store Actions(request, response).
Redux thunx is an outdated library.
Saga is Advanced library.

Why Saga? In sagas debouncing is available by default.

8. Explain React lifecycle methods?

React component lifecycle has three categories – Mounting, Updating and Unmounting.
Mounting – Birth of your component
Update – Growth of your component
Unmount – Death of your component

React Component LifeCycle Hooks

        1. constructor
        2. componentWillMount()
        3. render()
        4. componentDidMount()
        5. componentWillReceiveProps()
        6. shouldComponentUpdate()

        // component kill methods

        7. componentWillUpdate()
        8. componentDidUpdate()
        9. componentWillUnmount()

Recently Added LifeCycle Hooks

Context API, useEffect, useState --- Newly added version by version

Explanation:

# Constructor()

        constructor will execute at booting time of component --constructor will execute only once
        Define state in constructor

# componentWillMount()

        componentWillMount() will execute after constructor
        componentWillMount() will execute only once
        in general we will do the initial modifications in state
        in general we will set global parameters like width, height

# render()

        after componentWillMount() automatically render() function will execute
        render() is mandatory lifecycle hook(main lifecycle hook)
        in general, we will place presentation logic in render()
        when ever change detected in state or props automatically this lifecycle hooks will execute

# componentDidMount()

        after render function immediately componentDidMount() life cycle hook will execute
        in general we will make asynchronous calls in ComponentWillMount()
        this is recommended state to change the state of component

# componentWillReceiveProps()

        when component will receive props from redux

# shouldComponentUpdate()

        if we want to update the state return "true" else "false"

# UNSAFE_componentWillUpdate()

        death method --> perform cleanup operations

# componentDidUpdate()

        if we integrate any third party UI elements
        plugin logic will write here

# componentWillUnmount()

        Before killing the component componentWillUnmount is executed.
        death method --> perform cleanup operations


9. Call() -- if we want to create second memory location will interact with 1st memory location.

Apply – if we want to pass array instead of independent parameter

Bind() - merge memory location 1 and memory location 2 -->merge 2 memory locations-->new memory location.

What is the USE? Call function advanced function APPLY, call and apply advanced version is bind().
Purpose is same. Call, bind, apply –used to access 2 objects in different memory location

10. What is the current ES version? ES6 -2015, ES9, JS24

11. What are different positions in CSS ?
The position property specifies the type of positioning method used for an element.

There are five different position values:

static: HTML elements are positioned static by default.

relative: An element with position: relative; is positioned relative to its normal position.

fixed: An element with position: fixed; is positioned relative to the viewport, which means it always stays in the same place even if the page is scrolled. 
The top, right, bottom, and left properties are used to position the element.

absolute: An element with position: absolute; is positioned relative to the nearest positioned ancestor (instead of positioned relative to the viewport, like fixed).

sticky: An element with position: sticky; is positioned based on the user's scroll position.


12. What is shallow copy and deep copy? 

A shallow copy creates a new object with references to the same memory locations as the original object for nested properties. 
This means changes to nested objects in the copy will affect the original object.

javascript example: 
const originalObject = { a: 1, b: { c: 2 } };
const shallowCopy = { ...originalObject };

shallowCopy.b.c = 3;
console.log(originalObject.b.c); // Output: 3

Deep Copy
A deep copy creates a new object with new memory locations for all nested properties, ensuring changes to the copy don't affect the original object.

JavaScript Example:

javascript
const originalObject = { a: 1, b: { c: 2 } };
const deepCopy = JSON.parse(JSON.stringify(originalObject));

deepCopy.b.c = 3;
console.log(originalObject.b.c); // Output: 2

===============================================================================================

First Round: 30 minute React and Javascript.

1. current Project?

2. advantages of react?
    * Simple to build Single Page Application(by using Components - component based architecture).
    * React is cross platform and open source(Free to use)
    * Lightweight and very fast(Virtual DOM)
    * Large Community and Ecosystem.
    * Testing is easy.

3. hooks? some examples useState, useEffect?

    * React Hooks are inbuilt functions provided by React that allow functional components to useState and lifecycle features.
    * Before Hooks, class components lifecycle methods were used to maintain state in React Applications.
    * To use React hook first we first have to import it from React Library.

The useState hook enables functional components to manage state.
useState() working: useState() function accept the initial state value as the parameter and returns an array with 2 elements:
1. The first element is the current state value(count in this code).
2. Second element is the function that is used to update the state(setCount in this code).
The concept of assign array elements to individual variables is called array destructing.

The useEffect Hook in React is used to perform side effects in functional components.
For example, data fetching from API, subscriptions or any other operation that needs to be performed after the component has been rendered.

4. what is redux?

//state management(centralized store)
Redux is a predicatable state container for JavaScript apps. 
Redux acts as centralized store for state management in your application.
Advantages:
Single Source of Truth: The State of the application is stored in a single object.
State is Read-Only: The only way to change the state is to emit an action, an object describing what happened.
Changes are made with Pure Functions: Reducers are pure functions that take the previous state and an action, return the next state.

5. what is synthetic event?

a synthetic event is a cross-browser wrapper around the browser's native event. 
It combines the behavior of supported events of different browsers into one API, ensuring that events work identically across all browsers.

6. Event delegation?
Event delegation is a technique in JavaScript where a single event listener is attached to a parent element to handle events for
all of its child elements. 
Instead of attaching individual event listeners to each child, the parent element "delegates" the handling of events to its children. 
This approach leverages event bubbling, where an event on a child element propagates up the DOM tree to its parent elements. 


7. Why is javascript is synchronous not asynchronous?
JavaScript is primarily synchronous, running one piece of code at a time. 
However, it can handle asynchronous tasks using callbacks, promises, and async/await. 
This allows JavaScript to remain responsive by doing other work while waiting for time-consuming operations to finish.

8. What is the current ES version? ES6 -2015, ES9, JS24

9. object methods?
object.keys
object.values
object.freeze - we can't modify or delete from object
object.seal - we can modify but can't delete or add.

10. how to add properties to object?
object.assign()

11. suppose car has color, model and features, add some more properties of basic car?

12. create a object in javascript in jsfiddle?

const city ={
    name: 'austin',
    population: '10million',
}
city.street = '';

13. object.prototype?

14. coding question:
const fruits = [{name: 'apples', quantity: 500},
{name: 'bananas', quantity: 500},
{name: 'oranges', quantity: 150},
{name: 'kiwi', quantity: 150}];

show output: [[apples, bananas], [oranges, kiwi]];


//hint: use reduce

15. how browser knows javascript? JavaScript is preinstalle in browser.
if you write in typescript? it will convert the typescript to javascript.

use TS compiler

16. hoisting?

Hoisting is a behavior in JavaScript where variable and function declarations are moved to the top of their respective scopes during 
compilation phase, before the code is executed. This means that regardless of where variables and functions are declared in the code, 
they are treated as if they are declared at the beginning of their scope.

example:
console.log(x); //output: undefined
var x = 5;
console.log(x); //output: 5

the declaration of x is hoisted to the top, but not its initialization. That's why the first `console.log outputs undefined.

let and const declarations are hoisted but not initialized. This leads to a "temporal dead zone" where accessing the variable before its declaration results in a ReferenceError.

console.log(y);
// throws ReferenceError: Cannot access 'y' before "initialization"
let y = 10;



17. async/ await

The purpose of async/await is to simplify the syntax for working with Promises, making asynchronous code easier to write and read. 
It allows you to write asynchronous code that looks and behaves more like synchronous code.

// function that returns a promise
function fetchData() {
    return new Promise((resolve)=>{
        setTimeout(()=> resolve("data fetched"), 2000);
    });
}

// using async/await
async function getData() {
    console.log("fetching data...");
    const result = await fetchData();
    console.log(result);
    console.log("Data processing complete");
}

getData();

// output:
fetching data...
data fetched
Data processing complete

18. event bubbling? event capturing?

DOM elements are HTML Element. Parent , Child, Subchild.

Click Subchild -->Subchild, Child, Parent will execute.

The Events are propagating from down to top is called Event Bubbling.


What is Event Capturing? If I click parent only parent will execute. If I click child -->parent, child will execute. 
Propagation of Events from top to bottom is called Event Capturing.

React.js interview

19. what total experience in react.js till now? 12+

20. Which redux? redux-Toolkit:

Redux is a predicatable state container for JavaScript apps. Redux acts as centralized store for state management in your application.

Redux Toolkit is an offical, opinionated toolset for efficient Redux development.
It simplifies store setup, reduces boilerpate, and includes useful tools like createSlice and createAsyncThunk.

import {configureStore} from '@reduxjs/toolkit'; //import
const store = configureStore({
    reducer:{
        //pass all reducers
    },
});

export default store;

===============================================================================

Interview Question and answers

1. Tell me about yourself.

2. Which version of react? v16.8

3. How to optimize performance in react ?

1. Memoization with useMemo and useCallback:  Use this hooks to memoize values and, reducing unnecessary recalculations.
2. Optimizing Renders with React.Fragment: Use it to avoid unnecessary wrapper elements that could cause additional DOM nodes.
3. Lazy loading with React.lazy: Use it to load components lazily, reducing the intial bundle size and imporving intial loading performance.
4. Code splitting: Employ code splitting to divide your application into smaller chunks that are loaded on demand, improving initial load times.
5. Optimizing Images and Assets:  Compress and optimize images, use responsive images and leverage lazy loading for images to reduce network and rendering overhead.


4. What is difference between Promise.all() and race?

Promise.all() waits for all promises to settle (either resolve or reject), and resolves with an array of all resolved values or rejects as soon as one promise rejects.

Promise.race() resolves or rejects as soon as the first promise settles (either resolves or rejects).

5. difference between useMemo and useCallback?

Key Differences:

    useMemo: Memoizes the result of a computation (value). It helps with performance optimization by avoiding recalculating expensive values.

    useCallback: Memoizes the function itself, ensuring the function reference remains the same between renders unless its dependencies change. 
    It's mostly useful when passing functions as props to avoid unnecessary re-renders in child components.

6. Have you used async/await? use?

async: Declares a function that will always return a Promise.

await: Pauses the execution of the async function until the Promise resolves or rejects.

7. What are hooks in react? use?

useState: Manages state in functional components.
useEffect: Manages side effects in functional components.
useContext: Consumes context in functional components.
useReducer: Manage state with a reducer function, For More complex state management.
useRef: Accesses DOM elements or stores mutable values.
useCallback: performance improvement usecase
useMemo: performance improvement usecase.

8. did you work on custom hooks?

Custom Hooks in React are JavaScript functions that allow you to reuse stateful logic across multiple components.
They enable you to extract and share common logic without repeating code, promoting code reusability and separaration concerns.

c1, c2, c3, c4, c5--> one custom hooks --> state
Advantages:
Code Reusability: Custom hooks allow you to reuse stateful logic without duplicating code.
Separation of Concerns: They help spearate the logic from the component's structure, making the code more modular and easier to maintain.
Cleaner Code: By Moving common logic into custom hooks, components become cleaner and more focused on their core responsibilites.

9. Can we useHelp() hook instead of custom hook?

If useHelp() is a custom hook you've created or imported, then yes, you can use it just like any other hook.

Custom hooks don't replace built-in hooks; they are for organizing reusable logic. You can still use built-in hooks inside your custom hooks if needed.

10. what is callback?

Passing "one function" to "another function" as an argument called as "CallBack"

11. what is callback hell?

Callback hell" refers to a situation in programming where multiple asynchronous operations are handled using nested callback functions,
creating a complex and difficult-to-read code structure, often resembling a pyramid shape; 
to avoid it, use techniques like Promises and the async/await syntax to manage asynchronous operations in a more linear fashion,
making your code cleaner and easier to maintain. 

12. have you worked on NodeJS?

Node.js is commonly used for backend development, APIs, real-time applications (like chat apps), and more. 
It leverages non-blocking, event-driven architecture, making it ideal for I/O-heavy tasks like handling HTTP requests, reading files, and querying databases.

I can help with many aspects of Node.js development, including:

    Creating web servers using frameworks like Express.js.

    Working with databases (like MongoDB, MySQL, PostgreSQL) through libraries like mongoose or sequelize.

    Building APIs (RESTful APIs, GraphQL, etc.).

    Managing asynchronous operations (with callbacks, promises, and async/await).

    Implementing middleware for routing and error handling.

    Integrating third-party services (like payment gateways, email services, etc.).

    Optimizing performance (using clustering, worker threads, etc.).

    Deploying Node.js applications (on cloud platforms like AWS, Heroku, etc.).

13. difference between fetch and axios module?

fetch is a built-in JavaScript API that returns a Promise. It is native to the browser and doesn't require installing any additional libraries.

axios is a third-party library that also returns a Promise. It needs to be installed via npm or yarn (e.g., npm install axios).

Fetch Example:

fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));

Axios Example:

axios.get('https://api.example.com/data')
  .then(response => console.log(response.data))
  .catch(error => console.error('Error:', error));


14. call api in react syntax?

axios.get('https://api.example.com/data')
  .then(response => console.log(response.data))
  .catch(error => console.error('Error:', error));

15. what is hoisting? explain with example?

console.log(a); // Uncaught ReferenceError: a is not defined
let a; 

console.log(a); // Uncaught ReferenceError: a is not defined
let a = 10;

Hoisting is a behavior in JavaScript where variable and function declarations are moved to the top of their respective scopes during the compilation phase, before the code is executed. 
This means that regardless of where variables and functions are declared in the code, they are treated as if they are declared at the beginning of their scope.

example:
console.log(x); //output: undefined
var x = 5;
console.log(x); //output: 5

the declaration of x is hoisted to the top, but not its initialization. That's why the first `console.log outputs undefined.

let and const declarations are hoisted but not initialized. This leads to a "temporal dead zone" where accessing the variable before its declaration results in a ReferenceError.

console.log(y);
// throws ReferenceError: Cannot access 'y' before "initialization"
let y = 10;


16. What is promise?

 - Promises Establishes the communication between "producer" and "consumer".
 
        - Promises also called as "special javascript objects".
 
        - we will create Promises by using "Promise" class constructor.
 
        - Promises have 3 states
 
            1) success  (resolve)
 
            2) error    (reject)
 
            3) pending
 
        - we will consume promises by using "then()"

/*
    let promise1 = new Promise((resolve,reject)=>{
        resolve("tomorrow i will discuss async & await keywords");
    });
    promise1.then((posRes)=>{
        console.log(posRes);
    },(errRes)=>{
        console.log(errRes);
    });     //tomorrow i will discuss async & await keywords
*/

17. What is synchronous and asynchronous calls?

Synchronous calls block the program until the current task finishes. Everything happens in sequence.

Asynchronous calls allow the program to continue executing while waiting for a task to complete, preventing it from freezing or being blocked.

18. What operations did you perform in NodeJS?

    HTTP Server: Set up basic web servers to handle requests and responses.

    REST APIs: Created APIs for handling CRUD operations using Express.

    File Operations: Used the fs module to read, write, and manipulate files.

    Database Integration: Worked with databases (e.g., MongoDB) using libraries like Mongoose.

    Event-driven: Utilized the EventEmitter for event-driven programming.

    Asynchronous Programming: Managed asynchronous operations using Promises and async/await.

    Middleware: Built custom middleware in Express for additional functionality (e.g., logging, authentication).

Node.js offers a robust environment for developing scalable, event-driven applications and handling backend services, APIs, and tasks efficiently.

19. callback hell resolve?

Callback Hell can be mitigated by:

    Modularizing code: Break down tasks into smaller functions.

    Using Promises: Chain asynchronous operations and handle errors in a clean way.

    Using Async/Await: Write asynchronous code that looks synchronous, improving readability.

    Using Libraries like Async.js: Manage complex flows in a more elegant and concise way.

    Using Event Emitters: For managing more complex workflows that involve multiple events.

The async/await approach is generally the most modern and readable method, and it resolves the deep nesting of callbacks effectively, improving code quality and maintainability.

20. What is a closure in JavaScript?

    - if any inner function holding the outer function data, then such scenario called as closure.

21. can we write application in redux instead of redux-saga?

Yes, you can write applications using Redux without using Redux-Saga. Redux itself is a state management library, 
while Redux-Saga is a middleware used for handling side effects (like async actions such as fetching data from an API, interacting with external services, etc.).

22. what is difference redux, redux-thunk, redux-saga?

Redux is for managing the state of your application.

Redux-Thunk is a simple middleware for managing simple async logic like API calls or timeouts.

Redux-Saga is a middleware that handles complex side effects using generator functions, making it ideal for handling advanced async logic
(e.g., canceling tasks, running multiple tasks in parallel, and managing retries).

23. explain how redux architecture works? example?

Redux Data Flow

    User Interaction or Events trigger an action.

    The action is sent to the store using the dispatch function.

    The store forwards the action to the appropriate reducer.

    The reducer computes a new state based on the action.

    The store updates the state with the new value.

    The updated state can be accessed by React components or any part of the app.

This process follows the unidirectional data flow in Redux, where actions trigger state updates, and the components re-render based on the updated state.

24. what is react 19 features?

The New Additional Hooks in React 19:-

1. useFormStatus
-Tracks form submission status dynamically.
-Eliminates manual state tracking for pending operations.

2. useActionState
-Combines form actions and states into one seamless hook.
- Perfect for server-side rendered applications.

3. useOptimistic
-Supports optimistic Ul updates for async operations.
- Makes rollbacks smooth if operations fail.

4. use
-Brings promises and async context handling directly into components.
-Enhances Suspense for better async rendering.

25. what is useRef() hook?

The useRef hook is used to access and interact with DOM elements directly and to persist mutable values across renders without causing re-renders.



26. useLayoutEffect? useLayoutEffect fires before the browser repaints the screen. You can measure layout here.

useLayoutEffect: Synchornous Side effects.

27. what is synchronous vs asynchronous call?

Synchronous Call:

    A synchronous call means that the code is executed in a sequential, blocking manner. 
    The program executes each statement one after another, waiting for the previous one to finish before moving on to the next.

    In other words, each operation must complete before the next one begins.

Asynchronous Call:

    An asynchronous call allows certain tasks to run in the background while the program continues executing other code. 
    It doesn't block the rest of the program, and the operation may complete at a later time.

    Common asynchronous operations include fetching data from an API, setTimeout, Promises, or async/await syntax.


React

performance opt

Javascript



=========================================

Es6 features
ES6 is ECMAScript 6. It is nothing but Javascript Version.
ES6 allows let and const for variable declaration.
	 we have 8 types of functions  (ES6-ES11)
	     1) Named Functions
	     2) Anonymous Functions / Arrow Functions  (ES6)
	     3) Rest Parameters in Functions
	     4) Default Parameters in Functions
	     5) Optional Parameters in Functions
	     6) IIFE (Immediate Invokable Functional Expressions) (ES9) (2019)
	     7) Generator Functions
    8) Constructor Functions.



    Promises
    --------
        - Promises Establishes the communication between "producer" and "consumer".
 
        - Promises also called as "special javascript objects".
 
        - we will create Promises by using "Promise" class constructor.
 
        - Promises have 3 states
 
            1) success  (resolve)
 
            2) error    (reject)
 
            3) pending
 
        - we will consume promises by using "then()"
*/
 
 
 
/*
    let promise1 = new Promise((resolve,reject)=>{
        resolve("tomarrow i will discuss async & await keywords");
    });
    promise1.then((posRes)=>{
        console.log(posRes);
    },(errRes)=>{
        console.log(errRes);
    });     //tomarrow i will discuss async & await keywords
*/
 
	3. What is Functional Component?
A functional component is just a plain JavaScript function which accepts props as an argument and returns a React element.

A class component requires you to extend from React.Component and create a render function which returns a React element. 

=========================================================================
200 React JS Interview Q & A

React Basics-1
Q1. What is React? What is the Role of React in software development?
React is open source Javascript Library.
React is used for building user interfaces(UI).
React Simplifies the creation of SPA by using reusable components.

Q2 what are the key Features of React?
7 key features:
1. Virtual DOM
2. Component based architecture
3. Reusability & Composition
4. JSX (Javascript XML)
5. Declarative Syntax
6. Community & Ecosystem
7. React Hooks.
Virtual DOM: React utilizes a virtual representation of the DOM, allowing efficient updates by minimizing direct manipulation of the actual DOM, resulting in improved performance.

Component-Based Architecture: React structures user interfaces as modular, reusable components, promoting a more maintainable and scalable approach to building applications.

Reusability & Composition: React enables the creation of reusable components that can be composed together, fostering a modular and efficient development process.

JSX(JavaScript XML): JSX is a syntax extension for JavaScript used in React, allowing developers to write HTML like code within JavaScript, enhancing readbility and maintainability.

Declarative Syntax: React have a declarative programming style(JSX), where developers focus on "what" the UI should like and React handles the "how" behind the scenes. This simplify the code.

Community & Ecosystem: React benifits from a vibrant and extensive community, contributing to a rich ecosystem of libraries, tools and resources, fostering collaborative development and innovation.

React Hooks: Hooks are functions that enable functional components to manage state and lifecycle features, providing a more concise and expressive way to handle component logic.



Q3 what is DOM? What is the difference between HTML & DOM?

DOM(Document Object Model) represents the web page as a tree-like structure which allows Javscript to dynamically access and manipulate the content and structure of a web page.


Q4 What is virtual DOM ? Difference between DOM & Virtual DOM?

React uses a virtual DOM to efficently update the UI without re-render the entire page, which helps improve performance and make the application more responsive.

Reconciliation (React Libraries)

DOM                                                 Virtual DOM
1. DOM is actual representation of the webpage.      1. Virtual DOM is lightweight copy of the DOM.
2. Re-renders the entire page when updates occur.    2. Re-render only the changed parts efficently.
3. Can be slower, especially with frequent updates.  3. Optimized for faster rendering.
4. Suitable for static websites and simple applications 4. ideal for dynamic and complex single-page applications with frequent updates.


Q5 What are React Components? What are the main elements of it?

In React, a component is a reusable building block for creating user interfaces.

//1. Import the React Library
import React from "react";

2. Define a functional component
function Component(){
    //3. Return JSX to describe the component's UI
    return(
        <div>
            <h1>i am a react reusable component</h1>
        </div>
    );
}
//4. Import the component to make it available
//for use in other files
export default component;

Q6 What is SPA (Single Page Application)?

A Single Page Application(SPA) is a web application that have only one single web page.
whenever user do some action on the website, then in response content is dynamically updated without refreshing or loading a new page.

Q7 What are the 5 advantages of React?

1. Simple to build Single Page Application(by using Components - component based architecture).
2. React is cross platform and open source(Free to use)
3. Lightweight and very fast(Virtual DOM)
4. Large Community and Ecosystem.
5. Testing is easy.

Q8 What are the disadvantages of React?
React is not a good choice for very small applications.

Q9 What is the role of JSX in React? (3 points)

1. JSX stands for JavaScript XML.
2. JSX is used by React to write HTML-Like code.
3. JSX is converted to Javscript via tools like Babel.(Because browsers understand JavaScript not JSX.)


Q10 what is the difference between Declarative & Imperative Syntax?

Declarative                                                         
1. Declarative syntax focuses on describing the desired result without specifying the step-by-step process.
2. JSX in React is used to write declarative syntax.

Imperative
1. Imperative syntax involves step by step process to achieve a particular goal.
2. Javascript has an imperative syntax.

React Basics-2 
Q11 What is Arrow Function Expression in JSX?

The arrow function expression syntax is a concise way of defining functions.

//Arrow function Expression
const ArrowFunc = (props) => {
    return (
        <div>
            <h1>{props.name}</h1>
        </div>
    );
};

export default ArrowFunc;


Q12 How to Setup React first project?

1. Install Node.js from link. nodejs.org

2. Install code editor for writing the code. VS Code link --> download

3.  Open VS Code --> terminal --> npx create-react-app my-app --> takes 5-6 minutes

4. VS code --> file --> open folder --> MY-APP --> open terminal --> npm start


Q13 What are the Main files in React project?

        Request    
Browser  ---->      index.html --> Single Page

                       ^ >        
          <-----      index.js--> entry point(JS)
        Display             ^
comp1.js, comp2.js, comp3.js -----App.js ==> Root Component

Q14 How React app Load & display the components in browser?

index.html --> Single page which loads index.js by React libraries.

index.js --> Replace root element of index.html file by App component

App.js --> Root Component which is the container of all the child components.

child component.js --> custom child components placed over app component.


Q15 What is the difference between React & Angular?

React                                                                   Angular
React and Angular both are used to create single page UI applications using components.
1. React is a Javascript Library.                                   1. Angular is a complete Framework.
2. React uses virtual DOM which makes it faster.                    2. Angular uses a real DOM.
3. React is smaller in sixe and lightwight and therefore faster sometime.  3. Angular is bigger because it is a complete framework.
4. React depends on external libraries for many complex features, so      4. Since Angular is a complete framework, therfore it provide built-in support for features like routing, forms, validation and HTTP requests.
developer has to write many lines of code for complex functionalities

5. React is simple to learn and more popular than Angular.              5. Angular is slightly difficult to learn as it has Typescipt, OOPS concept and many more thing.


Q16 What are the other 5 JS frameworks other than React?

Angular
Vue.js
AngularJS
Backbone.js
Ember.js

Q17 Whether React is Framework or Library? what is the difference?

Library: Developers import the libraties at the top and then used it functions in components.
React is commonly reffered to as a Javscript Library

Framework: Developers need to follow a specific structure or pattern defined by the framework.
Angular is a framework.

@Component({
    selector:'app-root',
    templateUrl: './app.component.html',
    styleUrls:['./app.component.css']
})
export class AppComponent{
    title = "Hello World";
}


Q18 How React provide Reusability & Composition?
React provides Reusability and Composition through its component-based architecture.
Reusability: once you create a component, you can re-use it in different parts of your application or even in multiple projects.
Composition: Composition is creating new and big components by Components by combining existing small components. Its advantage is, change to one small component will not impact other components.


Q19 What are State, Stateless, Stateful and state management teams?

"State" refers to the current data of the component.

Stateful or state management means when a user performs some actions on the UI, then the React application should be able to update and re-render the data or state on the UI.


Q20 What are Props in JSX?
Props(properties) are way to pass data from a parent component to a child component.

React Basics-3 
Q21 What is NPM? What is the role of node_module folder?
NPM(Node Package Manager) is used to manage dependencies for your React project, including the React Library itself.

node_modules folder contains all the dependencies of the project, including the React libraries.



Q22 What is the role of public folder in React?
Public folder contains static assets that are served directly to the user's browser, such as images, fonts, and the index.html file.



Q23 What is the role of src folder in React?

src folder is used to store all the source code of the application which is then responsible for the dynamic changes in your web application.


Q24 What is the role of index.html page in React?

index.html file is the main HTML file(SPA) in React application.
here the div with id="root" will be replaced by the component inside index.js file.


Q25 What is the role of index.js file & ReactDOM in React?

ReactDOM is a Javascript library that renders components to the DOM or browser.

The index.js file is the javascript file that replaces the root element of the index.html file with the newly rendered components.


Q26 What is the role of App.js file in React?

App.js file contain the root component(App) of React Application.

App Component is like a container for other components.

App.js defines the structure, layout, and routing in the application.


Q27 What is the role of function & return inside App.js?

1. The function keyword is used to define a JavaScript function that represent your React component.
2. function is like a placeholder which contains all the code or logic of component.
3. The function takes in props as its argument(if needed) and return JSX.
return is used to return the element from the function.

Q28 Can we have function without a return inside App.js?

Yes, a function without a return statement is possible.
In that case, your component will not render anything in UI.
The common use case is for logging purpose.

Using arrow function

const FuncWithoutReturn = ()=>{
    console.log("no return");
}

Q29 What is the role of export default inside App.js?
Export statement is used to make a component available for import using "import" statement in other files.

import React from "react";

const AppChild = (props) =>{
    return <h1>hi</h1>
}

export default AppChild;


Q30 Does the file name & component name must be same in React?

No, the file name and the component name don't have to be the same.
However, it is recommended to keep the same for easier to organize and understand your code.

React -4 JSX

Q31 What is the role of JSX in React? (3 points)

1. JSX stands for JavaScript XML.
2. JSX is used by React to write HTML-Like code.
3. JSX is converted to Javscript via tools like Babel.(Because browsers understand JavaScript not JSX.)

function App(){
    return(
        <div className="App">
            <h1>Hello!</h1>
        </div>
    );
}

Q32 What are the 5 Advantages of JSX?

1. Improve code readability and writability
2. Error checking in advance(Type safety)
3.support JavaScript expressions
4. Improved performance
5. code Reusability.


Q33 What is Babel?

Babel in React is used to transpile JSX syntax into regular Javscript which browser can understand.


Q34 What is the role of Fragment in JSX?

In React, a fragment is a way to group multiple children's elements.
Using a Fragment prevents the addition of unnecessary nodes to the DOM.

<Fragment>
<div>vijay</div>
<div>reactjs</div>
</Fragment>

Q35 What is Spread Operator in JSX?

The Spread operator(...) is used to expand or spread an array or object.

function App() {
    const props = {name: "vijay", id:1};
    return (
        <ChildComponent {...props}/>
    );
}

function ChildComponent(props){
    return <div>{props.name},{props.id}</div>;
}


Q36 What are the types of Conditional Rendering in JSX?

Conditional Rendering

1. If /else statements 

2. Ternary Operator

3. && operator  - returns truthy value.

4. Switch statement


Q37 How do you iterate over a list in JSX? What is map() method?

map() method allows you to iterate over an array and modify its elements using a callback function.


Q38 Can a browser read a JSX file?

No, browsers cannot directly interpret or understand JSX files. 
Babel takes JSX and converts it into equivalent Javascript code that browsers can understand.


Q39 What is Transpiler? What is the difference between Compiler & Transpiler?

A Transpiler is a tool that converts source code from one high-level programming lanaguage(JSX) to another high-level programming language(JavaScript).
Ex: Babel.

A Compiler is a tool that converts high-level programming language (Java) into a lower-level language(machine code or byte code).


Q40 Is it possible to use JSX without React? 

Yes, it's possible to use JSX without React by creating your own transpiler like Babel.
However, this is not recommended since JSX is tightly integrated with React and relies on many React-specific features.


React- 5 Components-Functional/Class

Q41 What are React Components ? what are the main elements of it?

In React, a component is a reusable building block for creating user interfaces.

//1. Import the React Library
import React from "react";

//2. Define a functional component
function Component(){
    //3. Return JSX to describe the component's UI
    return(
        <div>
            <h1>react reusable component</h1>
        </div>
    );
}

//4. Export the component to make it available
// for use in other files
export default Component;

Q42 What are the Types of React Components? What are Functional Components?

Types of Components

1. Functional Components: They are declared as a JavaScript function. 
They are stateless component, but with the help of hooks, they can now manage state also.

2. Class Components

Q43 How do you pass data between functional components in React?

props(properties) are a way to pass data from a parent component to a child component.

Q44 What is Prop Drilling in React?
Prop drilling is the process of passing down props through multiple layers of components.


Q45 Why to Avoid Prop Drilling? In how many ways avoid Prop Drilling?
1. Maintenance: Prop drilling can make code harder to maintain as changes in data flow require updates across multiple components.
2. Complexity: It increases code complexity and reduces code reability.
3. Debugging: Debugging becomes challenging when props need to be traced through numerous components.

5 ways to avoid Prop Drilling

1. Using Context API
2. using Redux
3. using Component Composition
4. using Callback Functions
5. Using Custom Hooks

Q46 What are class components in React?

1. Class Components are defined using JavaScript classes.
2. They are stateful components by using the lifecycle methods.
3. The render method in a class component is responsible for returning JSX.


import React, {Component} from 'react';

class AppClass extends Component{
    render(){
        return<h1>hello</h1>;
    }
}
export default AppClass;


Q47 How to pass data between class components in React?

this.props can be used in child component to access properties/data passed from parent component.


class ParentComponent extends Component{
    render(){
        const dataToSend = "hello from parent";
        return(
            <div>
                <ChildComponent message={dataToSend} />
            </div>
        );
    }
}
export deault ParentComponent;



class ChildComponent extends Component{
    render(){
        return(
            <div>
                <p>Message:{this.props.message}</p>
            </div>
        );
    }
}

export default ChildComponent;

//output: Message: hello from parent



Q48 What is the role of this keyword in class components?

this keyword is used to refer to the instance of the class.


Q49 What are the 5 differences btw Functional components & class components? 

Functional Component                                                     Class Component

1. Syntax: Defined as JS function.                                      1. Defined as a JS(Es6) class.
2. State: Orginally stateless but can now maintain state using hooks.   2. Can Manage local state with this.state.
3. Lifecycle methods: No                                                3. Yes
4. Readbility: more readable & Concise.                                 4. Verbose(complex).
5. this keyword: No                                                     5. Yes(Access props using this.props)
6. Do not have render method.                                           6. have render method.


React- 6 Routing

Q50 What is Routing and Router in React?
Routing: Routing allows you to create a single-page web application with navigation, without the need for a full-page refresh.
React Router: React Router is a library for handling routing and enables navigation and rendering of different component based on the URL.


Q51 How to implement Routing in React?
Command to install router:
npm install react-router-DOM

Step1: Install React Router
Step2: Create navigation
Step3: Create Routes


Q52 What are the roles of <Routes> & <Route> component in React Routing?
The <Routes> Component is used as the root container for declaring your collection of routes.
The <Route> component is used to define a route and specify the component that should render when the route matches.
for example, if user enter websitename.com/about in url then matching "About" component will be rendered.

Q53 What are Route Parameters in React Routing?
Route parameters in React Router are a way to pass dynamic values(data) to the component as part of the URL path.

// userId is the route parameters
<Route path="/users/:userId" component={userProfile}/>


Q54 What is the role of Switch Component in React Routing?
Switch component ensures that only the first matching<Route> is rendered and rest is ignored.
Example: Switch is commonly used to handle 404 or not found routes.

Q55 What is the role of exact prop in React Routing?
exact prop is used with the <Route> component to match exactly to the provided path.

//with exact
//only match about
<Route path="/about" exact component={About} />     note: not supporting "/anout/team, /about/contact 


React- 7 Hooks -useState/useEffect

Q56 What are React Hooks? What are the Top React Hooks?
1. React Hooks are inbuilt functions provided by React that allow functional components to useState and lifecycle features.
2. Before Hooks, class components lifecycle methods were used to maintain state in React Applications.
3. To use React hook first we first have to import it from React Library.

//import React, {UseState} from "react":
useState: State
UseEffect: side effects
useContext: Context
useReducer: Complex State
useCallback: Memoization
useMemo: Performance
useRef: Refs  
useLayoutEffect: Synchornous Side effects.


Q57 What are State, Stateless, Stateful and State Management terms?
"state" refers to the current data of the component.
Stateful or statemanagement means, when a user performs some actions on the UI, then the React application should be able to update and re-render that data or state on the UI.


Q58 What is the role of useState() hook and how it works?

The useState hook enables functional components to manage state.
useState() working: useState() function accept the initial state value as the parameter and returns an array with 2 elements:
1. The first element is the current state value(count in this code).
2. Second element is the function that is used to update the state(setCount in this code).
The concept of assign array elements to individual variables is called array destructing.

import React, {useState} from "react";
function UseState(){
    //array destructing
    const [count, setCount] = useState(0);
    const increment = () =>{
        setCount(count + 1);
    }
}

return (
    <div>
    <p>Count:{count}</p>
        <button onClick={increment}>Click</button>
    </div>
);
export default UseState;


Q59 What is the role of useEffect(). How it works & what is its use?

The useEffect Hook in React is used to perform side effects in functional components.
For example, data fetching from API, subscriptions or any other operation that needs to be performed after the component has been rendered.

Q60. What is useEffect() hook and when to use it?
useEffect()  is called after the component renders. Example: side effects.
useEffect() function will accept 2 parameter: (Effect function, dependency array)

Q61 What is Dependency Array in useEffect() hook?
Dependecies array(optional) act as triggers for useEffect to rerun;meaning if any of the dependencies values change, the code inside useEffect() will be executed again.
Ex: userId --> due to multiple dependencies

Q62 What is the meaning of the empty array[] in the useEffect()?
An Empty array[] indicates that the effect function should only run once.

React- 8 Hooks -useContext/useReducer

Q63 What is the role of useContext() hook?
useContext in React provides a way to pass data from parent to child component without using props.
avoid prop drilling.


Q64 What is createContext() method? what are Provider & Consumer Properties?
createContext() function returns an object with Provider and Consumer properties.
The Provider property is responsible for providing the context value to all its child components.
useContext() method or Consumer property can be used to consume the context value in child components.


Q64 When to use useContext hook instead of props in real application?
Use useContext instead of props when you want to avoid prop drilling and access context values directly within deeply nested components.

Props are good from component 1 --> component 2
useContext is good for multiple components  Ex: Comp1--> Comp2--> Comp3 -->Comp4

Advantages:
1. Theme Switching(Dark/Light): you can centralize and pass the theme selection of the application from the parent to all the deep child components.
2. Localization(language selection): you can centralize and pass the language selection of the application from the parent to all the child components.
3. Centralize Configure settings: Common configuration settings like API endpoints can be centralized and change in the parent component will pass the setting to all its child components.
4. User Preferences: Any other user preferences apart from theme and localization can also be centralized.
5. Notification System: Components that trigger or display notifications can access the notification state from the context.

React- 11 Component LifeCycle Method-1 

Q65 What are component life cycle phases? 3

Component Life cycle Phases.
1. Mounting Phase. (Component creation started) - This phase occurs when an instance of a component is being created and inserted into the DOM.
2. Updating Phase (Component updates): This phase occurs when a component is being re-rendered as a result of changes to either its props or state.
3. Unmounting Phase(Removal from the DOM): This phase occurs when a component is being removed from the DOM.


Q66 What are component life cycle methods?

Component lifecycle methods are special methods that get called at various stages of a component's life.
Mounting Phase:
=====================
1. constructor()
2. getDerivedStateFromProps()
3. render()
4. componentDidMount()

Updating Phase
====================
render()
componentDidUpdate()
getDerivedStateFromProps()
shouldComponentUpdate()
getSnapshotBeforeUpdate()

Unmounting Phase
========================
componentWillUnmount()



Q67 What are constructors in class components ? when to use them?

Mounting Phase
===============
Constructor()

constructor is a special method that is called when an instance of the class is created.
Constructor is used to intializing the component's state or performing any setup that is needed before the component is rendered.

Q68 What is the role of super keyword in constructor?

super keyword is used in the constructor of a class component to call the constructor of the parent class.
This is necessary to ensure that the initialization logic of the parent class is executed.

class ConstructorExample extends Component{
    constructor(props){
        super(props);

        //Initalize the State
        this.state = {
            count: 0,
        ;}
    }
    render(){
        return(
            <h2> Count:{this.state.count}</h2>
        );
    }
}

export default ConstructorExample;


Q69 what is the role of render() method in component life cycle?

Mounting Phase, Updating Phase -- render()

Render() method returns the React elements that will be rendered to the DOM.


Q70 How the state can be maintained in a class component?

Two step process to maintain state:

1. this.setState() method is used to update the state.
2. this.state property is used to render the update state in DOM.

class StateComponent extends Component{
    constructor(props){
        super(props);
        this.state = {
            count: 0; //initializing the state
        };
    }
    render(){
        return(
            <div>
                <h2>Counter: {this.state.count}</h2>
                <button onClick={this.handleInc}>Increment</button>
            </div>
        );
    }
    handleInc = () =>{
        this.setState((prevState)=>({
            count: prevState.count + 1,
        }));
    };
}

export default StateComponent;

Q71 What is the role of componentDidMount() method in component life cycle?

ComponentDidMount() lifecycle method in React is the part of mounting phase and is called after a component has been rendered to the DOM.
Mostly used for side effects. For example, external data fetching or setting up subscriptions.

Mounting Phase
===============
componentDidMount()

1. Rendered after constructor intialization.
2. Rendered after componentDidMount() to run side effects(ex: loading data from external API) and then call render() method of updating phase again.


React- 13 Controlled & Uncontrolled Components

Q72 What are controlled components in React?
A controlled component is a component whose form elements(like input fields or checkboxes) are controlled by the state of the application.


Q73 What are the differences btw Controlled & Uncontrolled components?

Controlled Components                                               Uncontrolled Components
1. Values are controlled by React State.                            1.Values are not controlled by React State.
2. Event handlers update React state.                               2. No explicit state update; values can be accessed directly from the DOM.
3. Don't depend on useRef()                                         3. Commonly uses useRef() to access form element values.
4. Re-renders on state changes.                                     4. Less re-rendering since values are not directly tied to React state.
5. A recommended and standard practice for form handling in React.  5. useful in certain scenarios but less commonly considered a best pratice.


Q74 What are characteristics of controlled components?

characteristics of controlled components:
1. State Control: The value of the form element is stored in the component's state.
2. Event Handling: Changes to the form element trigger an event(e.g., onChange for input fields)
3. State Update: The event handler updates the component's state with the new value of the form element.
4. Re-rendering: The Component re-renders with the updated state, and the form element reflects the new value.

Q75 What are the advantages of using controlled components in React forms?

Top 3 benefits of using controlled components in React forms:
1. In controlled components, form elements have their values managed by React State, ensuring a single source of truth.
2. This approach facilitated predicatable and synchronized updates, making it easier to implement features such as form validation, and dynamic rendering, and seamless integration with React's lifecyle methods.
3. Controlled Components offer better control and maintainability compared to uncontrolled components, making them the best pratice for handling forms in React applications.


Q76 How to handle forms in React?
The preferred and recommended approach for handling forms in React is by Using controlled components.


Q77 How can you handle multiple input fields in a controlled form?
Maintain separate state variables for each input field and update them individually using the onChange event.


Q78 How do you handle form validation in a controlled component?
By using conditional rendering based on the state and validate input values before updating the state.

Q79 In what scenarios might using uncontrolled components be advantageous?
Uncontrolled components can be beneficial when integrating with non-React libraries, or when dealing with forms where controlled components are not possible.


*** React- 14 Code Splitting 

Q80 What is code splitting in React?
Code splitting is a technique to split the JavaScript bundle into smaller chunks, which are loaded on-demand.

Q81 How to implement code splitting in React?
3 steps for code splitting in React:
1. Use React.lazy() to lazily import components.
2. wrap components with Suspense to handle loading.
3. Configure your build tool(e.g webpack) for dynamic imports.

Q82 What is the role of Lazy & Suspense methods in React?
React.lazy is a function that allows you to load a component lazily.
It enables code splitting by allowing you to import a component asynchronously/dynamically, meaning component is loaded only when needed only.

The Suspense component is used to display a fallback UI while the lazily loaded component is being fetched.


Q83 What are the Pros & Cons of code splitting?

5 Pros of Code Splitting:
1. Faster Initial Load Time:  Code splitting reduces the initial load time of your application by only loading the necessary code for the current view or feature. Good for performance.
2. Optimized Bandwidth Usage: By Loading only, the code needed for a specific page, it reduces the amount of data transferred over the network. Good for slow network.
3. Improved caching: Smaller, more focused code chunks are more likely to be cached by the browser.
4. parallel loading: Multiple smaller chunks can be loaded simuntaneously, leading to faster overall loading times.
5. Easier Maintenance: Code splitting can make your codebase more modular, independent and easier to maintain.

5 Cons of code splitting:
1. Complexity: Implementing code splitting introduces additional complexity to your application. This complexity can make the development process slow.
2. Tooling Dependecies: Proper code splitting often requires specific build tools and configurations, such as Webpack and Babel. Managing these tools is challenging.
3. Potential for Runtime Errors: Dynamically loading code at runtime can introduce the possibility of runtime errors. careful testing is necessary to catch such issues.
4. Increased Number of Requests: Code splitting may increase the number of HTTP requests needed to fetch all the necessary chunks. This can impact performance.
5: Learning Curve: Developers who are new to code splitting may need time to understand the concepts and best practices. This can be a challenging.


Q84 What is the role of the import() function in code splitting?
The import() function returns a promise that allow dynamic loading of modules.

Q85 What is the purpose of the fallback prop in Suspense?
The fallback prop provides a loading indicator or UI while the dynamically imported component is being loaded.

Q86 Can you dynamically load css files using code splitting in React?
Yes, using dynamic import() for CSS files allows you to load styles on-demand along with the corresponding components.

Q87 How do you inspect & analyze the generated chunks in React application?
Use tools like Webpack Bundle Analyzer to analyze the size and composition of chunks.

*** React- 15 Others

Q88 What is a higher-order component in React?
A Higher-Order Component is a component which takes another component as an argument and adds extra features to another component.
HOC can be used for providing logging functionality to all the components in a reusable way.


Q89 What are the 5 Ways to Style React components ? Explain inline styles?

we use separate style sheets.
5 ways to style React components
1. Inline styles
2. CSS Stylesheets
3. CSS-modules
4. Global Stylesheets
5. CSS Frameworks


Q90 What are the difference between React & React Native?

React                                                           React Native
1. React is a library.                                          1. React Native is a framework.
2. React is used for building web interfaces.                   2. React native is used for building mobile applications.
3. Run on web browsers.                                         3. Run on IOS and Android platforms.
4. HTML and CSS are used for UI.                                4. Native UI Components(e.g., View, Text) are used for UI.
5. Deployed as web applications.                                5. Deployed through app stores(e.g., App store, Google Play)


Q91 What is GraphQL?
GraphQL is a query language for APIs(Application Programming Interfaces) and a runtime for executing those queries with your exisitng data.
GraphQL and React are often used together. React components can use GraphQL queries to fetch the data required for rendering.

Q98 What are the Top 3 ways to achieve state management? when to use what in React?
1. useState Hook: 
    When to use: Simple component-level state.
    Reason: Ideal for applications having small components and isolated state because it is Lightweight and built into React only.
2. Context API:
    When to use: Prop drilling avoidance for sharing global data.
    Reason: Simplifies data passing through the component tree, reducing the need for manual prop drilling.
3. Redux:
    When to use: Large-scale applications with complex state.
    Reason: Centralized store and actions provide a predicatable state management pattern, aiding in debugging and scalability.

Q92 How can you implement authentication in a React application?

Front-end/Client-side                                               Middleware/server-side/backend(node.js, asp.net, django)

browser                     1. POST:{username, password}           2. authenticate & create JWT Token
                            3. Return Response {JWT token}
4. Store JWT token at local storage
                            5. Request Data{JWT token: Header}     6. Validate token signature

                            7. Send Data
8. Display data on browser

Q93 What is the use of React Profiler?
React Profiler is a set of tools in React that allows developers to profile(analyze) the performance of a React application.


Q94 What is the difference between Fetch & Axios for API calls in React?

Fetch                                                                                                   Axios
1. fetch is a built-in JS function, so doesn't require any additional libraires.                        1. Axios is a third-party library, that simplifies the process of making HTTP requests.
2. fetch returns Promises, making it easy to work with asynchromous code using async/await syntax.      2. Axios allows you to use interceptors, which can be good for tasks like request/response logging, authentication, and error handling.
3. If you want to keep http requests simple, fetch is a good choice.                                    3. If you want to intercept http request/response or improve error handling then Axios has more features to do it.


Q95 What are the popular Testing Libraries for React?

Jest
React Testing Library
Enzyme
Cypress

Q96 How can you Optimize Performance in React application?
1. Memoization with useMemo and useCallback:  Use this hooks to memoize values and, reducing unnecessary recalculations.
2. Optimizing Renders with React.Fragment: Use it to avoid unnecessary wrapper elements that could cause additional DOM nodes.
3. Lazy loading with React.lazy: Use it to load components lazily, reducing the intial bundle size and imporving intial loading performance.
4. Code splitting: Employ code splitting to divide your application into smaller chunks that are loaded on demand, improving initial load times.
5. Optimizing Images and Assets:  Compress and optimize images, use responsive images and leverage lazy loading for images to reduce network and rendering overhead.


Q97 Explain Reactive Programming with example?
Reactive programming is a programming paradigm that focuses on reacting to changes and events in a declarative and asynchronous manner.
Ex: Google search type --> gives hints --> events are captured.

Declarative means a programming style where you write the code for what you want to achieve, rather than specifying step-by-step how to achieve it.
For Ex: JSX in React has declarative syntax.

Asynchronously means an action that doesn't block other actions.

Q98 In how many ways can we implement Reactive Programming in React?

1. State and Props: Reacting to changes in local component state and passing data reactively through props.
2. React Hooks: Leveraging useState and useEffect hooks for managing state and side effects in functional components.
3. Event Handling: Reacting to user interactions through event handling and updating state accordingly.
4. Context API: sharing and managing global state reactively across components using the Context API.
5. Redux: using state management libraries like Redux for managing complex application state reactively.
6. Component LifeCycle Methods: Using class components and lifecycle methods for handling side effects and updates.
7. Async/await: utilizing async/await syntax for handling asynchronous operations reactively.
8. RxJS and Observables: Levering RxJS for handling aysnchronous operations and data streams in a reactive manner.

Q99 How to pass data from child component to parent component in React?
Parent provides a callback function to child and then child component can then invoke this callback to pass data back to the parent.


======================================================================================================================================

ReactJS Interview Question and Answers

1. What is react.js?
   React is an open-source Javascript library developed for building user interfaces, particularly for single-page applications.

2. What are the major features of react?
   Virtual DOM: React uses a virtual DOM to improve performance by minimizing direct DOM manipulations.
   JSX: JSX stands for Javascript and XML, which allow writing HTML in React components.
   Components: React is Component-based, meaning the UI is built using reusable components.
   One-way Data Binding: Data flows in one direction, making the application easier to understand and debug.
   High Performance: React Optimizes updates by using a virtual DOM and efficently re-rendering components.
   Undirectional Data Flow: Data flows in a single direction, which provides better control over the entire application.

3. What is Virtual DOM and how it works?

Virtual DOM is a lightweight, in-memory representation of the real DOM elements generated by React Components.
React keeps a copy of the actual DOM structure in memory, called the virtual DOM, and uses it to optimize updates and rendering.

Rendering -----> Updating ----> Diffing Algorithm -----> Batch Updates -----> Reconciliation

4. What are components in react?
Components are the building blocks of a React application. They are reusable pieces of UI that can be nested, managed, and handled independently.
Class Based Components 
Functional Components

5. Explain Class components with example?

class nameofComponent extends component then render method return JSX.

import React, {Component} from 'react;
class ClassComponentExample extends Component {
    render(){
        return <h1>Hello</h1>;
    }
}
export default ClassComponentExample;

4. Explain functional components with example?

2-ways

import React from 'react';

function FunctionalComponent() { // function keyword
    return <h1>Hello</h1>
}
export default FunctionalComponent;

import React from 'react';
const FunctionalComponent = () => { //const arrow function
    return <h1>hello</h1>
}
export default FunctionalComponent;

5. What is JSX?
JSX stands for Javascript XML.
It allows us to write HTML elements in Javascript and place them in the DOM without using methods like createElement() or appendChild().

6. How to export and import components?
we can export components using export default or named exports, and import them using import.
inorder to reuse a component we need to export.

exportcomponent1.js

import react from "react";

const Home = () =>{
    return <h1>Home!</h1>;
};

export default Home;


=================

importcomponent1.js

import React from "react";
import Home from "./home";

const App = () =>{
    return (
        <div>
        <Home />
        </div>
    );
};

export default App;

7. How to use nested components?

Header component --> common for layout. <Menu /> is nested inside header.
App Component --> nested <Header /> component

8. What is state in react ?

button --> counter value  1-->2 --> 3 value is stored in state.

In React, state is an object that represents the parts of the app that can change. 
Each component can have its own state, which can be managed within the component and used to render the UI.
When the state changes, React re-renders the component to reflect the new state.

9. What is state in react?

import React, {Component} from "react";
//class based component
class Counter extends Component {
    constructor(props){
        super(props);
        //Initializing state
        this.state ={
            count: 0;
        };
    }
    render() {
        return(
        <h1>Count: {this.state.count}</h1>
        );
    }
}
export default Counter;


-----------------------------
//functional based component
import React, {useState} from "react";  //useState
function Counter(){
    //Initializing state using useState Hook
    const [count, setCount] = useState(0);  //update state with setCount

    return (
        <h1>Count: {count}</h1>
    );
}
export default Counter;

=========================================
//class component
import React, {Component} from "react";
class Counter extends Component {
    state = {
        count: 0
    }
    render(){
        return(
            <h1> Count: {this.state.count}</h1>
        )
    }
}
export default Counter; toow  


10. How to update state in react?
State in React is updated using the setState method in class components or the useState hook in functional components.
// class
this.setState({count: this.state.count + 1})

//functional
const [count, setCount] = useState(0);

11. What is setState Callback?
The setState method can accept a callback function as the second argument, which is executed once the state has been updated and the component has re-rendered.

12. Why you should not update state directly, explain wiht example?
Updating state directly does not trigger a re-render of the component, leading to inconsistencies in the UI.
Instead, always use setState (class-based) or state(functional-based) hooks.

13. What are props in react?
Props(properties) are used to pass data and event handlers to child component.(communicate b/w components)
props ensure a one-way data flow, from parent to child.
props cannot be modified by the child component that receives them. (read-only)

Example:
import React from "react";

//child component
function Greeting(props){
    return <h1>hello, {props.name}!</h1>
}

//parent component
function App(){
    return(
        <div>
        <Greeting name="vijay" />
        <Greeting name="krishna" />
        </div>
    );
}

export default App;
==============================

14. What is difference between state and props ?

       state                                            
    State is built-in object used to store data that may change over the lifecycle of a component.
    It is managed within the component itself.

    State is mutable. 
    It can be updated using the setState method in class components or the useState hook in functional components.

    State is local to the component and cannot be accessed or modified by child components.

    Props
    Props(properties) are used to pass data from a parent component to a child component.
    They are read-only and immutable within the child component.

    Props are immutable. Once passed to child component, they cannot be modified by the child.

    Props are passed from parent component to a child component and can be accessed by the child.


15. What is lifting state up in react?
Lifting State Up is a pattern in React where state is moved up to the closest common ancestor of components that need to share that state.
Single Source of Truth: By managing the state in the parent component, you can ensure that the state is consistent across multiple child components.
Simplified State Management: The state logic is centralized, making it easier to maintain and debug.

Parent <----- child (button). Manage state in single parent component.

16. What is children prop in react?
The children prop is a special property in React used to pass the content that is nested inside a component.

Child Component --> {props.children}
Parent Component --> App() <h1> <p><h2><button>

17. What is defaultProps in React?
defaultProps is used to set default values for the props in a component.

Greeting.defaultProps ={
    name: "Guest",
}
//usage
<Greeting /> //renders "hello, guest"

18. What are fragments in react and its advantages?
Fragments allow you to group multiple elements without adding extra nodes to the DOM.
<React.Fragment>
<li>Item, 1</li>
<li>Item 2</li>
</React.Fragment>
<>
</>

19. How to use styling in react.js?
we can ise inline styles, CSS stylesheets, or CSS-in-JS libraries like styled-components.

inline styles
function StyledComponent(){
    return(
        <div
        style={{
            color: "blue",
            backgroundColor: "lightgray"
        }}>
        This is Styled Component.
        </div>
    );
}


styles.css
.container{
    color: blue,
    backgroundColor: lightgray
}
import "./styles.css"
function StyledComponent(){
    return <div className = "container"> this is styled component</div>;
}

20. How can you conditionally render components in React?
We can use Javascript conditional operators (like if, &&, ?:) to conditionally render components.

21. How to render list of data in react?
we can use the map function(ES6) to iterate over an array and render each item.

22. What is Key prop?
The key prop is a unique identifier for each element in a list, used by React to identify which items have changed, are added, or removed.


23. Why indexes for keys are not recommended?
Using indexes as keys can lead to performance issues and unexpected behavior when list items are reordered or removed.
Keys should be unique and stable.

24. How to handle buttons in react?

25. How to handle inputs in react?
we can use controlled components where form data is handled by the component's state.

26. Explain lifecycle methods in react?
Lifecycle methods in React are special methods that get called at different stages of component's lifecycle.
Mounting: When a component is being inserted into the DOM.
Updating: When a component's state or props change.
Unmouting: when a component is being removed from the DOM.

class LifecycleDemo extends React.Component{
    componentDidMount(){
        console.log("component mounted"); //render once only.
    }
    componentDidUpdate(prevProps, prevState){ //gives prevProps and prevState
        console.log("component updated"); 
    }

    componentWillUnmount(){
        console.log("component will unmount"); //cleanup things
    }

    render(){
        return <div> Lifecycle method</div>
    }
}

27. What are the popular hooks in react and explain it's usage?

useState: Manages state in functional components.
useEffect: Manages side effects in functional components.
useContext: Consumes context in functional components.
useReducer: Manage state with a reducer function, For More complex state management.
useRef: Accesses DOM elements or stores mutable values.
useCallback: performance improvement usecase
useMemo: performance improvement usecase.

28. What is useState and how to manage state using it?

import React, {useState} from 'react';

function Counter(){
    const [count, setCount]= useState(0);

    return(
        <div>
        <p> you clicked {count} times</p>
        <button onClick={()=>setCount(count+1)}>Click Me</button>
        </div>
    );
}
export default Counter;

29. What is useEffect hook and how to manage side effects?
useEffect is a hook that manages side effects like data fetching(prevState), subscriptions, or manually changing the DOM.

import React, {useEffect, useState} from 'react';

function DataFetcher(){
    useEffect(()=>{}, [], []); //Empty array means this effect runs only once.

    useEffect(()=>{}, [dependency]); //run if dependency value changes.

  useEffect(()=>{
    return ()=>{};

  }, []) //cleanup method.
  retunr <div></div>;
}
export default Counter;


30. How to implement data fetching in react.js?
ask interviewer question--> how to implement onClick on page load?

31. How to manage loading state?
const [loading, setLoading] = useState(false);

32. What is prop drilling and how to avoid it? What is ContextAPI?
Prop drilling occurs when you pass data through many layers of compoments.
It can be avoided using the Context API or state management libraries like Redux.

A ---> B, C--> D, A-->D.

33. What is Context API in React, and why is it used?
Context API in React provides a way to share values(like data or functions) between components without having 
to pass props through every level of the component tree. It is used to avoid the prop drilling.

import React, {createContext} from 'react';

//create a Context
const MyContext = createContext();

//Provider component

//wrap context in root component.

// A, B, C, D
global state

34. How do you consume context using the useContext hook?
The useContext hook allows functional components to access context values directly.

35. How can you update context values?
//create context
//provider component
//pass context name
//update value by onClick() function.

36. How do you use multiple contexts in a single component?
//we need to wrap multiple context
//useContext(firstContext) and secondContext.

37. What are the advantages of using the Context API over prop drilling?
Context API reduces the need for prop drilling, making the code more readable and maintainable.
It allows for easy sharing of state and functions across the component tree without passing props through every level.

//without Context API(prop drilling)
<Parent>
<Child>
<GrandChild value={value} />
</Child>
</Parent>


//with Context API
<MyProvider>
    <GrandChild />
</MyProvider>


38. What is the useReducer hook, and when should you use it?
The useReducer hook is used for state management in React. 
It is suitable for handling more complex state logic compared to useState.

useReducer alternate of useState.

import React, {useReducer} from 'react';

const[state, dispatch] = useReducer(reducer, initialState);
//dispatch action with type property


39. Can you useReducer with complex state objects?
yes.

40. how do you pass additional arguments to the reducer function?

whenever we dispatch action using payload.

dispatch({type: 'update', payload:{value:42}});

41. How to do you handle side effects with useReducer?
Yes
we can useEffect inside the API call with data action.payload.

42. What is useRef Hook?

The useRef hook is used to access and interact with DOM elements directly
and to persist mutable values across renders without causing re-renders.


43. How can useRef be used to store mutuable values?
useRef can store any mutuable values, and changes to the ref do not cause re-renders.

44. What is forwardRef and when would you use it?
forwardRef is a function that allows you to pass refs through components to access DOM elements or child component instances.

45. How to manage forms in react?
Forms in React can be managed using controlled components where form data is handled bu the component's state.

//create JSX structure with form.

46. What are Custom Hooks and why do We Need Them?

Custom Hooks in React are JavaScript functions that allow you to reuse stateful logic across multiple components.
They enable you to extract and share common logic without repeating code, promoting code reusability and separaration concerns.

c1, c2, c3. c4.c5--> one custom hooks --> state
Advantages:
Code Reusability: Custom hooks allow you to reuse stateful logic without duplicating code.
Separation of Concerns: They help spearate the logic from the component's structure, making the code more modular and easier to maintain.
Cleaner Code: By Moving common logic into custom hooks, components become cleaner and more focused on their core responsibilites.

47. Implement useFetch custom hook/Custom hook example?

48. Implement useWindowResize custom hook?


49. What is React Router DOM and why is it used?

React Router DOM is a routing library built on top of React Router. 
It enables dynamic routing in web applications, allowing you to define routes and naviagte between different components without reloading the page.

Routing Version 6 latest.
moving 1 page to another page --> routing.

50. How do you create a basic route in React Router DOM?
A basic route is created using the Route component, which maps a URL path to a specific element.
<Route path = "/home" element = {<Home />} />

51. How to implement basic routing using react router dom?

file --> index.js

import {BrowserRouter, Routes, Route} from 'react-router-dom';

const App = () => (
    <BrowserRouter>
        <Routes>
            <Route path="/home" element={<Home />} />
            <Route path="/login" element={<Login />} />
        </Routes>
    </BrowserRouter>
);

export default App;

52. How to create a link to another route using React Router DOM?
Use the Link component to create navigation links.
import {Link} from 'react-router-dom';

<Link to="/home">Home</Link>
<Link to="/about">About</Link>

53. How do you use URL parameters/ Dynamic routing in React Router DOM?

/product list
1, 2,3, 4,5
<Route path="/user/:userId" element={<User />} />

54. How can you perform a redirect in React Router DOM?
use the Navigate component to perform a redirect.
<Navigate to="/home">;
//use navigate and to property


import {Navigate} from 'react-router-dom';

const Login = ()=>{
    const isLoggedIn = true;
    if(isLoggedIn){
        return <Navigate to="/home">;
    }
    return <div> please login</div>;
}

export default Login;

55. What is a Routes component on React Router DOM?
The Routes component is used to define a set of routes, where only the first matching route is rendered.

<Route path="/home" element={<Home />}

56. How do you handle nested routes in React Router DOM?

<Routes>
    <Route path="/dashboard" element={<Dashboard />}>
    <Route path="/home" element={<Home />}
</Routes>

57. How can you handle 404 errors (not found) in React Router DOM?
Use a Route without a path prop inside Routes to catch all unmatched routes.

const NotFound = () => <h1> 404-not found</h1>;

<Route path="*" element={<NotFound />}/>

58. How do you programtically naviagte using React Router DOM?
Use the useNavigate hook to navigate programtically within your components.

import {useNavigate} from 'react-router-dom';

const navigate = useNavigate();
navigate('/home');

59. Explain useCallback hook with example?
//callback function
The useCallback hook is used to memoize callback functions. 
This means that the function provided to useCallback will only be recreated if one of it dependencies has changed.
This is particularly useful when passing callbacks to child components that are optimized with React.memo, as it can prevent unnecessary renders.

60. Explain useMemo hook with example?
The useMemo hook is used to memoize expensive calcualtions so that they are not recalculated on every render.
It takes a function to compute a value and an array of dependencies, and it onlyy recomputes the value when one of the dependencies has changed.

//value

61. Explain React.memo with example?
React.memo is a higher-order component that memoizes the result of a component.
It prevents the component from re-rendering unless the props have changed. 
This is useful for optimizing performance by avoiding unecessary renders of pure components.

62. Explain the Reconciliation process in React and how it works?
Reconciliation is the process React uses to update the DOM efficiently.
It involves comparing the new Virtual DOM with the previous one and determining the minimum number of changes needed to update the actual DOM.

63. What are Pure Components?
PureComponent is a base class in React that implements shouldComponentUpdate with a shallow prop and state comparison.
It helps prevent unnecessary re-renders by ensuring that the component only re-renders when there are actual changes in props or state.

class childComp extends PureComponent{
    //class based components
}

64. Explain higher order component with example?
A Higher-Order Component (HOC) is a function that takes a component and returns a new component with added functionality.
HOCs are used for reusing component logic and enhancing components with additional behavior.

65. What is redux, explain core principles?
//state management(centralized store)
Redux is a predicatable state container for JavaScript apps. Redux acts as centralized store for state management in your application.
Advantages:
Single Source of Truth: The State of the application is stored in a single object.
State is Read-Only: The only wat to change the state is to emit an action, an object describing what happened.
Changes are made with Pure Functions: Reducers are pure functions that take the previous state and an action, return the next state.

66. What are actions in Redux, explain with example?
Actions are plain JavaScript objects that describe what happened in the application.
They must have a type property that indicates the type of action being performed.

//action.js
export const increment = () => ({type: 'INCREMENT'});
export const decrement = () => ({type: 'DECREMENT'});

67. Explain Reducers in Redux with an example?
Reducers are pure functions that take the current state and an action , and return a new state based on the action type.

const counterReducer = (state = intitialState, action)=>{
    switch(action.type){
        case 'INCREMENT':
        return {count: state.count +1};
        case 'DECREMENT':
        return {count: state.count - 1};
        default:
        return state;
    }
}

68. What is the role of the Redux Store?
The Store holds the whole state tree of the application. 
It allows access to the state via getState(), dispatching actions via dispatch(action), and registering listeners via subscribe(listener).


69. How do you connect React components to Redux store using connect?
The connect function connects a React component to the Redux store.
It maps state and dispatch to the component's props.

import { connect } from 'react-redux';

const mapStateToProps = (state) => ({count: state.count});
const mapDispatchToProps = {increment};

export default connect(mapStateToProps, mapDispatchToProps)(Counter);

70. How do you use the useSelector and useDispatch hooks in a functional React component?
useSelector is used to access the Redux state,
const count = useSelector((state)=>state.count)

useDispatch is used to dispatch actions in functional components.

const disptach = useDispatch();

71. What is Redux Toolkit?
Redux Toolkit is an offical, opinionated toolset for efficient Redux development.
It simplifies store setup, reduces boilerpate, and includes useful tools like createSlice and createAsyncThunk.

72. How to configure store in redux toolkit?
Redux Toolkit is an official, opinionated toolset for efficient Redux development.
It Simplifies store setup, reduxes biolerplate, and includes useful tools like createSlice and createAsyncThunk.

import {configureStore} from '@reduxjs/toolkit'; //import
const store = configureStore({
    reducer:{
        //pass all reducers
    },
});

export default store;

73. Explain createSlice in Redux Toolkit with an example?
createSlice is a function that generates action creators and action types, and create a reducer based on a object of "slice" reducers.

import {createSlice} from '@reduxjs/toolkit';

74. What are controlled components in React?
Controlled components are React components where the form data is handled by the React state.
The input's value is always driven by the React state.

75. What are uncontrolled components in React?
Uncontrolled components are React Components where the form data is handled by the DOM itself.
The input's value is not driven by the React state.

76. How do you optimize performance in React applications?
    Using useMemo and useCallback to memoize expensive calculations and functions.
    Implementing shouldComponentUpdate or using React.memo for Pure Components.
    Code Splitting and lazy loading.

77. What is code splitting in React?
Code splitting is a feature supported by React that allows you to split your code into various bundles which can then be loaded on demand.

import React, {Lazy, Suspense} from 'react';

<Suspense> provides fallback

78. What are render props in React? give an example?
Render props are a technique for sharing code between React components using a prop whose value is a function.
This function returns a React element and is used by the component to render part of its output.

79. What are portals in React?
Portals provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.
This is useful for things like modals, tooltips and overlays.

80. How do you implement lazy loading in React?
Lazy loading in React can be implemented using the React.lazy and Suspense components.
This allows you to load components on demand, improving initial load times.

81. How do you define props for a functional component in Typescript?

interface Props{}
const MyComponent: React.FC<Props>=({title, count}=>{})

82. How do you use the useState hook with Typescript?
We can define the type of the state variable by specifying it in the useStata generic.

const [count, setCount]= useState<number>(0);

83. How do you type event handlers in React with Typescipt?

const [value, setValue] = useState<string>('');

const handleChange = (e: React.changeEvent<HTMLInputElement>)=>{}
                                           <TextField> <Selectfield>


84. How do you handle optional props in React components with Typescript?
In Typescript, you can handle optional props by using the ? operator in the props interface or type alias.

interface Props{
    subtitle?: string;
}

85. How do you use the useReducer hook with Typescript?

86. How do you type the context API in React with Typescript?

87. How do you write a simple test in Jest?
Jest is a JavaScript testing framework maintained by Facebook. 
It is commonly used with React because it provides a simple and powerful testing solution with features like snapshot testing, coverage reporting, and built in assertions.

//JEST, RTL

test() or it() callback function.

88. How do you render a component for testing using React Testing Library?

import {render} from '@testing-library/react';
import MyComponent from './MyComponent';
test('renders MyComponent', ()=>{
    render(<MyComponent />);
});

89. How can you find elements in the DOM using the React Testing Library?
//first render the component, then check if we have the text "helloworld" use getByText
//if element toBeIntheDocument();

90. How do you simulate user events in React Testing Library?

//first render the component.
//then fireEvent.click(button);

91. How can you test component props with React Testing Library?
//first render the component.
expect //title present or not.

92. create a Controlled Input Component?

93. Implement toggle Visibility of a component?

94. Fetch Data from an API and Display it, along with loading state?

95. Create a Reusable Button Component with Props?

96. Build a Component that Uses and Effect to Perform Cleanup.

97. Implement a context with a Reducer for Global State Management?

98. Build a Component with Conditional Rendering Based on Props.

99. Implement a simple form Component?

100. how to handle erro in simple form component?