Previous Interview question and answers

1. Tell me about yourself and your journey into front-end development.

I am a core UI Developer with 12+ years of experience building .com websites for different organizations using HTML5, CSS3, JavaScript, Angular 18, React.js, and Redux.
In the past 2 years, I worked on the React migration team, where I converted the .net pages to react on united.com.
Frontend is React, and used ATMOS (Own library) components used company wide.

Worked on Security features for users where they can manage there account like Forgot password, Forgot MileagePlus number,
security questions, Sign-in features, Miles-Pooling, United Club pass, Recent Activity, dashboard updates and
KTN(Known Traveler Number), Accessibility guidelines features on united.com.

used middleware such as redux-saga to handle asynchronous tasks such as API calls, data fetching, and impure actions in a more organized and efficient way.

Previously worked with Accelerator team for Visa Inc. remediation of MBDA modules like Application Management, Account Management, Portfolio Management, Analytics, Recurring billing, Virtual Terminal, etc for bank users like Wells Fargo, Bank of America, etc

Capital Group worked on DAVIS Project. Davis stands for Data visualization where we build different highcharts using react and integrate into the AEM., the backend is Java. Previously I worked on Creative Workbench, a writing tool where articles are published on capital group websites.

At Cerner Corporation worked on the medical examination forms.

In Office Depot worked on black Friday reporting.

Satinos Technologies created a tax portal and a schoomin website for the Vignan schools.

2. Walk me through your latest project – what problems did you solve?

React migration - Converted pages in .net to react.
The new initiative worked on Miles-Pooling( points you get after traveling), TSA Precheck, Account security and management features, and Under18.

3. How does the virtual DOM work in React?

Suppose line of code is changed , processing is done on particular line.
It will process the whole code in real DOM. Virtual DOM is faster.

4. What’s the difference between props and state in React?

Props (short for "properties") are read-only and passed from a parent component to a child component.
They allow components to communicate by passing data down the component tree.
Since props are immutable within the receiving component, they cannot be changed by the component itself.

State, on the other hand, is mutable and managed within a component.
It represents data that can change over time due to user interactions or other factors.
A component's state can be updated using React's useState hook (in functional components) or
setState (in class components), causing the component to re-render.

5. What is useEffect and how have you used it in your projects?

In React, useEffect is a hook that allows you to perform side effects in functional components.
Side effects include things like fetching data, updating the DOM, setting up subscriptions, and cleaning up resources.

How useEffect Works:
useEffect runs after the component renders.

It can be configured to run only once, on every render, or when specific values change.

You can return a function inside useEffect to clean up resources (like removing event listeners or unsubscribing from an API).

<!-- import { useEffect, useState } from "react";

function ExampleComponent() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(`Count changed to ${count}`);

    return () => {
      console.log("Cleanup before next useEffect runs or component unmounts");
    };
  }, [count]); // Runs whenever "count" changes

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
} -->

How I've Used useEffect in Projects:
Fetching Data: I’ve used useEffect to fetch API data when a component mounts ([] as the dependency array).

Listening to Window Events: Tracking things like window resizing or scroll position changes.

Setting Up Timers: Managing intervals and timeouts for features like countdown timers.

Cleaning Up Resources: Removing event listeners or stopping subscriptions when a component unmounts.

6. How do you manage API calls and error handling in React?

Ans: 1. Using Fetch or Axios for API Calls
You can make API requests using fetch or axios. Axios provides some extra features like automatic JSON parsing
and request cancellation.

    2. Using Axios for Cleaner Code
    3. Handling Errors Gracefully
    4. Using useEffect for API Calls
    5. Avoiding Memory Leaks

7. What’s the folder structure you prefer for a scalable front-end project?

A well-organized folder structure is crucial for scalability, maintainability, and readability in a front-end project. Here’s the structure I usually recommend for React-based projects (but it applies to other frameworks as well):

/project-root
├── public/ # Static assets (favicon, index.html)
├── src/ # Main source code
│ ├── assets/ # Images, fonts, global styles
│ ├── components/ # Reusable UI components
│ ├── pages/ # Individual pages/views
│ ├── hooks/ # Custom React hooks
│ ├── utils/ # Utility/helper functions
│ ├── services/ # API calls, authentication logic
│ ├── contexts/ # Global state management (Context API)
│ ├── styles/ # Global styles or component-specific styles
│ ├── store/ # State management (Redux, Zustand, etc.)
│ ├── config/ # Environment variables, app settings
│ ├── routes/ # Centralized route definitions
│ ├── tests/ # Unit & integration tests
│ ├── index.tsx # App entry point
│ ├── App.tsx # Root component
├── .env # Environment variables
├── package.json # Dependencies & scripts
├── tsconfig.json # TypeScript config (if using TypeScript)
├── README.md # Documentation

8. What is the role of Express.js in the MERN stack?

Express.js plays a crucial role in the MERN stack by acting as the backend framework that connects the front end (React) with the database (MongoDB) via Node.js.. Here's how it fits into the stack:

🚀 Role of Express.js in MERN:

1. Handles HTTP Requests & Routes

Express.js provides a simple and flexible way to define API routes (GET, POST, PUT, DELETE) that interact with the MongoDB database.

2. Middleware Integration

It allows middleware functions that handle authentication, logging, error handling, and request parsing (like body-parser).

3. Database Connectivity

Express.js interacts with MongoDB (usually via Mongoose) to perform CRUD operations efficiently.

4. Server-Side Logic & Business Rules

This is where backend logic is implemented—handling authentication, form validation, and access control.

5. API Development for Frontend Communication

The React front end makes API calls to Express.js, which then fetches or modifies data in MongoDB.

9. How do you optimize performance in a React app?

1. Memoization with useMemo and useCallback: Use this hooks to memoize values and, reducing unnecessary recalculations.
1. Optimizing Renders with React.Fragment: Use it to avoid unnecessary wrapper elements that could cause additional DOM nodes.
1. Lazy loading with React.lazy: Use it to load components lazily, reducing the intial bundle size and imporving intial loading performance.
1. Code splitting: Employ code splitting to divide your application into smaller chunks that are loaded on demand, improving initial load times.
1. Optimizing Images and Assets: Compress and optimize images, use responsive images and leverage lazy loading for images to reduce network and rendering overhead.

1. Difference Between Flex and Grid
• Flexbox (Flex):
○ One-dimensional layout: Arranges elements in a row or column.
○ Ideal for simple layouts with horizontal or vertical alignment.
○ Responsive: Easily adapts to different screen sizes.
○ Great for navigation bars, footers, and single-dimensional content sections.
• CSS Grid (Grid):
○ Two-dimensional layout: Creates rows and columns for complex layouts.
○ Superior for intricate structures with precise positioning.
○ Responsive: Maintains flexibility across devices.
○ Perfect for dashboards, product listings, and multi-column layouts.
Visual Demonstration:
• Flex: Show a navigation bar with elements aligned horizontally.
• Grid: Display a product listing with items arranged in rows and columns.
Choosing Between Flex and Grid:
• For simple layouts or single-dimensional alignment, flexbox often suffices.
• For complex structures with precise positioning, opt for grid.
• They can even be combined for more versatile layouts.
Example (Code Snippet):
JavaScript
// Flexbox for a navigation bar
<nav style={{ display: 'flex', justifyContent: 'space-between' }}>
  <a href="#">Home</a>
  <a href="#">About</a>
  <a href="#">Contact</a>
</nav>
// Grid for a product listing
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))' }}>
  <div className="product">Product 1</div>
  <div className="product">Product 2</div>
  {/* More products... */}
</div>

1. getElementById vs. getElementByClass
   • getElementById:
   ○ Retrieves an element by its unique ID.
   ○ Faster when you know the exact ID.
   ○ Use for elements that should only appear once.
   • getElementsByClassName:
   ○ Returns an array of elements with the same class name.
   ○ Useful when you have multiple elements with the same class.
   ○ Can be less performant for large numbers of elements.
   Choosing Between getElementById and getElementByClass:
   • Use getElementById for elements with a unique ID.
   • Use getElementsByClassName for multiple elements with the same class.
   Example (Code Snippet):
   JavaScript
   const heading = document.getElementById('main-heading'); // Use for unique ID
   const buttons = document.getElementsByClassName('btn'); // Use for multiple buttons
   Use code with caution.

1. What are ES6 Features ?


    • Arrow Functions: Concise syntax for defining functions.

JavaScript
const greet = name => `Hello, ${name}!`;

    • Template Literals: Embedded expressions within strings for dynamic content.

JavaScript
const message = `Welcome, ${user.name}`;

    • Destructuring: Extract properties from objects or arrays.

JavaScript
const { firstName, lastName } = user;

    • Classes: Object-oriented programming with inheritance.

JavaScript
class Person {
constructor(name) {
this.name = name;
}

greet() {
console.log(`Hello, I'm ${this.name}`);
}
}

    • Modules: Organize code in reusable modules.

JavaScript
// myModule.js
export function add(a, b) {
return a + b;
}

// main.js
import { add } from './myModule.js';
console.log(add(2, 3));

13. What are promises ?


    • Promises: Represent the eventual completion (or failure) of an asynchronous operation.
    • Benefits:
    	○ Improved code readability and maintainability by handling asynchronous operations asynchronously.
    	○ Chaining of asynchronous operations for a more fluid flow.
    	○ Error handling for potential issues during asynchronous execution.

Code Example (Using Fetch API):
JavaScript
fetch('https://api.example.com/data')
.then(response => response.json())
.then(data => {
console.log(data);
// Process the data
})
.catch(error => {
console.error(error);
// Handle errors
});

14. Redux is a state management library for JavaScript applications, including React. It provides a centralized store to hold application state, actions to update that state, and reducers to handle those updates.
    • Store: Holds the entire application state as a single JavaScript object tree.
    • Actions: Plain JavaScript objects describing the intention to change the state.
    • Reducers: Pure functions that accept the current state and an action, returning the new state.
    Dispatcher.
    Pros of Redux:
    • Predictable State Management: Easier to reason about application state and track changes.
    • Improved Testability: Easier to test components in isolation due to centralized state.
    • Scalability: Well-suited for large and complex applications.
    Cons of Redux:
    • Boilerplate Code: Requires setting up stores, reducers, actions, and middleware.
    • Complexity: Learning curve for managing state with reducers and actions.

15. Why Fetch Inside useEffect?
16. We typically fetch data inside useEffect in React because it ensures
    the data is fetched only when the component is mounted (or when
    dependencies in the array change).
17. This prevents unnecessary re-renders on every update and improves performance.
18. Additionally, useEffect allows for easy cleanup of side effects
    like subscriptions when the component unmounts.

19. What are props in Reactjs ?

Building Blocks of Communication
Imagine building Lego houses. Each Lego piece has properties that
define its color, size, and shape. Similarly, in React, props are
properties passed down from parent components to child components.
They act as a way for components to communicate and share data.
This allows you to create reusable and dynamic components!

17. What are different Component Types:

React offers two main types of components:

Class Components: These are like blueprints defining how a
component behaves and renders. They use the class keyword and
allow for functionalities like state management and lifecycle methods.
Structured way.

Functional Components: These are simpler and more concise.
They are pure functions that take props as input and return JSX
to describe what the component renders. They're a great choice
for presentational components.

18. What are states in ReactJS ?

Think of state as the internal memory of a component.
It allows components to react to user interactions or data changes.
You can use the useState hook to manage state in functional components.

19. What are stateless components in react ?

Stateless components, essentially functional components,
don't manage internal state. They simply take props as
input and return JSX based on those props. This makes
them lightweight and easier to reason about.

Example of a Stateless Component:

function Greeting(props) {
return (
<div>
<h1>Hello, {props.name}!</h1>
</div>
);
}

20. What are arrow functions in JS ?

Arrow functions (introduced in ES6) are a
concise way to write JavaScript functions.
They're often preferred for their cleaner syntax,
especially when dealing with props and state in React components.

Example of an Arrow Function:
JavaScript

const handleClick = () => {
console.log('Button clicked!');
};
handleClick()

21. What is redux ? and when to use it ?

Redux (although not strictly required for basic React applications)
is a popular state management library for managing complex application
state. It provides a centralized store to hold your application's state,
actions to update that state, and reducers to handle those updates.
(Think of it as a central bank for your app's data!)

22. What is JSX is reactjs ?

JSX (JavaScript XML) is a syntax extension that allows you to write
HTML-like structures within your JavaScript code. This makes
it easier to visualize and build user interfaces in React components.

Example of JSX:

return (

  <div>
    <h1>Welcome to My App</h1>
    <p>This is some content.</p>
  </div>
);

23. What is strict mode in JS

React's Strict Mode is a development tool that helps identify potential
issues in your application code. It enables warnings for deprecated
features, lifecycle methods, and other potential problems,
allowing you to catch them early during development.

---

HTML Interview questions

1. HTML5 new features vs HTML4?

Major New Features in HTML5:

Semantic tags: <article>, <section>, <header>, <footer>, <nav>, <main>, etc., for clearer document structure and better SEO.

Multimedia: <audio> and <video> tags allow native embedding of media without third-party plugins.

Graphics: <canvas> for 2D drawing and animation, plus improved SVG support.

Form controls: New input types (email, date, color, etc.), validation, and attributes like placeholder, required, and autofocus.

APIs: Geolocation, offline storage (local/session storage), drag-and-drop, Web Workers for background processing, and WebSockets for real-time communication.

Simplified syntax: Easier doctype and cleaner markup.

Improved accessibility and SEO: Semantic elements help search engines and assistive technologies understand content structure.

2. Storage in HTML?

1. Local Storage (localStorage)

Stores data permanently until manually cleared.

Data is saved across page reloads and browser sessions.

Example:
localStorage.setItem("username", "Vijay");
console.log(localStorage.getItem("username")); // Output: Vijay

2. Session Storage (sessionStorage)

Stores data temporarily (only until the browser tab is closed).

Example:
sessionStorage.setItem("theme", "dark");
console.log(sessionStorage.getItem("theme")); // Output: dark

3. Cookies (document.cookie)

Used for small amounts of data, typically for tracking user sessions.

Sent to the server with each request.

Example:
document.cookie = "username=Vijay; expires=Fri, 31 Dec 2025 23:59:59 GMT";

4. IndexedDB

A powerful NoSQL database inside the browser.

Supports complex data storage, including objects.

Example:

let db;
const request = indexedDB.open("myDatabase", 1);
request.onsuccess = () => { db = request.result; console.log("Database opened successfully"); };

5. Cache API (Service Workers)

Used for storing resources like files, images, and responses for offline use.

Works well for Progressive Web Apps (PWAs).

Example:
caches.open("my-cache").then(cache => {
  cache.add("/index.html");
});



3. iframe HTML

<iframe>, short for inline frame, is an HTML element that lets you embed another document (webpage, video, map, etc.) 
inside the current webpage.

🚀 How <iframe> Works
An <iframe> allows you to load external content within a designated area on your site.

<iframe src="https://example.com" width="600" height="400"></iframe>

✅ Common Use Cases
Embedding YouTube videos, Google Maps, or third-party widgets.

Loading external pages without redirecting users.

Displaying ads or content from other sources.


4. HTML5 features

Semantic Elements

New elements like <section>, <article>, <header>, <footer>, and <nav> improve the structure and readability of web pages.

Multimedia Support

Native <audio> and <video> elements let you embed media without requiring third-party plugins like Flash.

Why HTML5 is Better?
✅ Eliminates dependency on external plugins 
✅ Enhances performance and SEO 
✅ Optimized for mobile-friendly websites 
✅ Enables interactive web applications


5. which video type support HTML5

✅ MP4 – Best for maximum compatibility across all browsers. 
✅ WebM – Optimized for the web with good compression and fast loading. 
✅ Ogg – Open-source, but less widely supported compared to MP4 and WebM.


6. Maximum heading tag size?
In HTML, heading tags range from <h1> to <h6>, with <h1> being the largest and <h6> being the smallest by default.


7. marque tag?
The <marquee> tag in HTML was used to create scrolling text or moving elements across a webpage. 
However, it's now deprecated and no longer recommended for use.

<marquee behavior="scroll" direction="left">This is moving text!</marquee>


8. DOM?
The DOM (Document Object Model) is a programming interface for web documents that represents the structure of an HTML or 
XML document as a tree-like hierarchy. 
It allows JavaScript to dynamically manipulate content, structure, and styles on a webpage.

🚀 Key Features of DOM

✅ Tree Structure Representation

The DOM represents an HTML page as a tree, where elements like <html>, <body>, and <div> are nodes.

✅ Dynamic Content Manipulation

Developers can use JavaScript to add, remove, and modify elements dynamically.

✅ Event Handling

The DOM enables event-driven programming, allowing interactions through events like clicks, key presses, and hovers.

✅ Cross-Browser Compatibility

Works across different browsers, ensuring uniform behavior of web pages.



9. CSS integrate type in React.js? external (index.css), internal, inline css

✅ Inline Styles – Uses JavaScript objects for styling. 
✅ CSS Stylesheets – Imports regular CSS files. 
✅ CSS Modules – Scoped styles to avoid global conflicts. 
✅ Styled Components – CSS-in-JS for dynamic styling. 
✅ Tailwind CSS – Utility-first approach with predefined classes.

React and JS Interview questions:

1. what is shouldComponentUpdate?

shouldComponentUpdate() is used to optimize performance by preventing unnecessary re-renders. 
It returns true (default) to allow rendering or false to block it.

Ex: 
shouldComponentUpdate(nextProps, nextState) {
  return nextProps.value !== this.props.value; // Only update if "value" changes
}

✅ Helps with performance optimization 
✅ Mainly used in class components (functional components use React.memo) 
✅ Not required unless optimizing complex UI updates

2. pure component?

A Pure Component in React is a class component that automatically implements shouldComponentUpdate() with a shallow prop 
and state comparison to prevent unnecessary re-renders.

Ex: import React, { PureComponent } from "react";

class MyComponent extends PureComponent {
  render() {
    return <h1>Hello, Pure Component!</h1>;
  }
}


3. Local Storage (syntax) vs session storage vs cookies


Syntax Examples
1️⃣ Local Storage (Stores data permanently)

localStorage.setItem("username", "Vijay"); // Set item
console.log(localStorage.getItem("username")); // Get item
localStorage.removeItem("username"); // Remove item

2️⃣ Session Storage (Clears when tab is closed)
sessionStorage.setItem("theme", "dark"); // Set item
console.log(sessionStorage.getItem("theme")); // Get item
sessionStorage.clear(); // Clear all items

3️⃣ Cookies (Stores small data, sent with HTTP requests)
document.cookie = "username=Vijay; expires=Fri, 31 Dec 2025 23:59:59 GMT; path=/";
console.log(document.cookie); // Get all cookies


4. size of local storage
The size limit for Local Storage in most modern browsers is around 5MB per domain. 
This means each website can store up to 5MB of data in Local Storage.

5. context in react js syntax?
In React.js, Context API allows you to manage global state without passing props manually at every level.

🚀 Syntax Example
1️⃣ Create Context:
const MyContext = React.createContext();
2️⃣ Provide Context:
<MyContext.Provider value={sharedData}>
  <ChildComponent />
</MyContext.Provider>

3️⃣ Consume Context:
const value = useContext(MyContext);

✅ Helps avoid prop drilling 
✅ Ideal for theme, authentication, and global state 
❌ Not a replacement for complex state management like Redux

6. es6 features

ES6 introduced powerful features for modern JavaScript development: 
✅ let & const – Block-scoped variable declarations. 
✅ Arrow functions – Shorter function syntax (()=>{}).
✅ Template literals – ${variable} inside backticks for dynamic strings. 
✅ Destructuring – Easy extraction of object/array properties. 
✅ Spread & Rest (...) – Expands or collects elements flexibly. 
✅ Default parameters – Assign default values in functions. 
✅ Classes – Simplified object-oriented programming. 
✅ Modules (import/export) – Enables modular code structure. 
✅ Promises – Handles asynchronous operations (then/catch). 
✅ Map & Set – New data structures for unique values and fast lookups.



7. why we use promises?

We use Promises in JavaScript to handle asynchronous operations efficiently. 
They help avoid callback hell and make code more readable by using .then() and .catch() for handling success and errors.

✅ Improves readability – Avoids nested callbacks 
✅ Handles async operations – Fetch API, database queries, timers 
✅ Error handling – .catch() method simplifies error management 
✅ Chaining support – .then() allows sequential execution

Ex:
fetch("https://api.example.com/data")
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error("Error:", error));


8. virtual DOM?

The Virtual DOM is a lightweight copy of the actual DOM that React uses to improve performance.

✅ Fast Updates – React updates the Virtual DOM first, then efficiently syncs with the real DOM. 
✅ Minimizes Re-renders – Uses diffing to update only necessary elements, avoiding full page refreshes. 
✅ Enhances Performance – Reduces direct manipulations of the real DOM, improving speed.

Example process: 
1️⃣ React updates Virtual DOM. 
2️⃣ It compares changes (diffing). 
3️⃣ Only necessary updates are applied to the real DOM.

9. props drilling?

Props drilling occurs when data (props) is passed deeply through multiple nested components in React, even when some components don’t need it.

✅ Problem: Makes code harder to manage in large applications. 
✅ Solution: Use Context API or state management (Redux, Zustand, etc.) to avoid unnecessary prop passing.


10. webpacks uses why? 

Webpack is a powerful JavaScript module bundler used to optimize and manage assets in web applications.

✅ Bundles & Minifies – Combines multiple files into one, reducing load time. 
✅ Code Splitting – Loads only necessary code for better performance. 
✅ Asset Management – Handles CSS, images, and fonts efficiently. 
✅ Hot Module Replacement – Allows real-time updates during development. 
✅ Tree Shaking – Removes unused code for a smaller bundle size.


11. without npm project will run?

Yes, a JavaScript project can run without npm, but it depends on how dependencies are managed.

🔥 Explanation:
Pure JavaScript Projects (Vanilla JS) can run without npm if dependencies are manually included via CDN or local files.

Node.js Applications may require npm for package management, but can use manual installation or alternative package managers like Yarn or PNPM.

React, Vue, or Angular Projects typically rely on npm for dependencies and won't run properly without a package manager.


12. how to start rendering in react.js project

🚀 Basic Steps to Start Rendering
✅ Import React and ReactDOM:
import React from "react";
import ReactDOM from "react-dom";
import App from "./App";


✅ Use ReactDOM.createRoot() (React 18+):
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);

✅ Ensure the root div exists in index.html:
<div id="root"></div>

This initializes the React app and renders the App component inside the root element.

13. how react code will get executed?

React code executes in the following steps:

✅ JSX Compilation – JSX is transformed into JavaScript using Babel. 
✅ Component Rendering – React creates the Virtual DOM. 
✅ Reconciliation – React compares Virtual DOM changes with the real DOM. 
✅ DOM Updates – React efficiently updates only necessary elements. 
✅ Event Handling – React listens for user interactions via synthetic events.


14. how to achieve optimization? 

React.js optimization can be achieved through several techniques:

✅ Use React.memo – Prevents unnecessary re-renders for functional components. 
✅ Use useCallback & useMemo – Optimizes function and value memoization. 
✅ Code Splitting – Load only required components using React.lazy & Suspense. 
✅ Avoid unnecessary state updates – Keep components minimal and optimize re-renders. 
✅ Virtualization – Improve performance for large lists with react-window. 
✅ Efficient rendering – Use key props correctly to avoid unwanted re-renders. 
✅ Avoid props drilling – Use Context API or Redux for state management.


15. difference between normal reducer and useReducer

✅ Normal Reducer – A function that manages state updates, typically used in Redux for global state management. 
✅ useReducer – A React hook that manages local component state using a reducer function, useful for complex state logic inside components.

Key Differences:

Normal Reducer works globally via Redux, while useReducer is for local component state.

useReducer is a React Hook, does not require Redux setup.

Redux Reducers use dispatch(actions), while useReducer relies on dispatch within the component.


16. class vs className

In HTML, class is an attribute used to define a CSS class for styling elements. 
In React (JSX), className is used instead of class, because class is a reserved keyword in JavaScript.

✅ HTML Example:
<div class="container">Hello</div>

✅ React Example:
<div className="container">Hello</div>


17. React Native

React Native is a framework for building mobile applications using React and JavaScript.

✅ Cross-platform – Develop once, run on both iOS & Android. 
✅ Uses JavaScript & JSX – Write mobile apps using familiar React syntax. 
✅ Native Performance – Renders UI components using native platform APIs. 
✅ Reusable Components – Share code between mobile and web applications. 
✅ Popular for mobile development – Used by apps like Instagram, Facebook, and Airbnb.

18. how many ways there to create react native app

You can create a React Native app in three main ways:

✅ Expo CLI – Easiest way, requires minimal setup (npx create-expo-app myApp). 
✅ React Native CLI – More customizable, allows direct access to native code (npx react-native init myApp). 
✅ Third-party tools – Tools like Ignite or ReNative for advanced setups.

19. redux saga (put, call, every)

Redux Saga is a middleware for handling side effects (like async API calls) in Redux using generator functions.

✅ put() – Dispatches an action to the Redux store. 
✅ call() – Calls a function (like an API request) and waits for the result. 
✅ takeEvery() – Listens for every occurrence of an action and runs a saga.

Example:
function* fetchDataSaga() {
  const data = yield call(api.getData);
  yield put({ type: "DATA_SUCCESS", payload: data });
}

function* watchFetchData() {
  yield takeEvery("FETCH_DATA", fetchDataSaga);
}


20. redux without api call

✅ Yes! Redux can manage state without API calls.

🚀 Use Cases Without API Calls:

UI State Management – Toggle dark mode, modal visibility.

Local Data Handling – Manage form inputs across components.

Client-Side Caching – Store temporary data for better performance.

Static Data Flow – Predefined data for UI updates.

Example without API calls:

const initialState = { count: 0 };

function counterReducer(state = initialState, action) {
  if (action.type === "INCREMENT") {
    return { count: state.count + 1 };
  }
  return state;
}


21. What is HOC? purpose?

A Higher-Order Component (HOC) in React is a function that takes a component as input and returns a new enhanced component.

✅ Purpose:

Code reusability – Share logic across multiple components.

Enhance components – Add additional functionality without modifying the original.

Example: Wrapping a component with authentication logic.

🚀 Example of HOC:

const withAuth = (Component) => (props) =>
  props.isAuthenticated ? <Component {...props} /> : <p>Please login</p>;


22. sort array without sort method, let arr = [1,5,7,2,3]

You can sort an array without using the sort() method by implementing a sorting algorithm manually, such as Bubble Sort or Insertion Sort.

🚀 Example: Bubble Sort
function bubbleSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // Swap values
      }
    }
  }
  return arr;
}

let arr = [1, 5, 7, 2, 3];
console.log(bubbleSort(arr)); // Output: [1, 2, 3, 5, 7]


23. closure? example
A closure in JavaScript is a function that remembers the variables from its outer scope even after the outer function has executed.

🔥 Example Closure Function
function outerFunction(x) {
  return function innerFunction(y) {
    return x + y; // `innerFunction` remembers `x` from `outerFunction`
  };
}

const add5 = outerFunction(5); 
console.log(add5(3)); // Output: 8

✅ Closure retains access to x even after outerFunction finishes. 
✅ Useful for encapsulation, maintaining private variables, and function factories.


24. let, var, const difference
In JavaScript, let, var, and const are used for variable declarations, but they differ in scope, mutability, and hoisting:

✅ var – Function-scoped, can be redeclared and updated, hoisted but uninitialized. 
✅ let – Block-scoped, cannot be redeclared, but can be updated, hoisted but uninitialized. 
✅ const – Block-scoped, cannot be reassigned or redeclared, must be initialized.

Ex: 
var a = 10; // Function-scoped
let b = 20; // Block-scoped
const c = 30; // Block-scoped, immutable

25. What is Hoisting?

Hoisting in JavaScript is the process where variable and function declarations are moved to the top of their scope before execution.

✅ Function hoisting – Allows calling a function before its declaration. 
✅ Variable hoisting – var is hoisted but initialized as undefined,
while let & const are hoisted but not initialized (cause errors if accessed before declaration).

temporal dead zone: it is zone where it belong.

26. function test(){
  var x = 10;
  var x;
  var x = 40;
  console.log("x is" + x);
}

test();
40

27. Explain the scope of temporal dead zone?
{
  //TDX starts
  const func = () => console.log(letVar);
  // TDZ
  let letVar = 3; // end TDZ
  func();
}

28. why var hoisiting is present in javascript?
var hoisting is present in JavaScript due to its interpreted nature and execution model.

🚀 Reasons for var Hoisting: 
✅ Historical Design Choice – JavaScript was originally designed for quick scripting, and var hoisting made it more flexible. 
✅ Function Execution Flexibility – Allows variables to be declared anywhere within a function but still accessible at the top. 
✅ Compilation Phase Handling – During execution, JavaScript hoists declarations (moves them to the top of their scope) before executing code.

29. Pure functions: Those functions that are deterministic in nature.

function areaofRectangle(length, width){
  return length * width;
}

areaofRectangle(10,20);
areaofRectangle(10,20);
areaofRectangle(10,30);
areaofRectangle(40,20);

30. Impure functions - those functions that are non-determinstic in nature.

function test(length, width){
  const temp = Math.floor(Math.random() * 10);
  return length * width * temp;
}
test(10, 20);

31. what is console.log('hello world') ; //logging , debugging.

console.log() is function.

32. shallow copy:  copy by reference

deep copy: copy by value

33. A shallow copy duplicates only the reference to nested objects, meaning changes to the copy affect the original. 
A deep copy creates an independent copy of all nested objects, ensuring no link to the original data.

🚀 Example in JavaScript: ✅ Shallow Copy (using Object.assign() or spread operator ...)
const obj1 = { name: "Vijay", details: { age: 30 } };
const shallowCopy = { ...obj1 }; 
shallowCopy.details.age = 35; 
console.log(obj1.details.age); // ❌ Changes original object (shallow copy)


✅ Deep Copy (using JSON.parse(JSON.stringify()) or structuredClone)

const obj2 = { name: "Vijay", details: { age: 30 } };
const deepCopy = JSON.parse(JSON.stringify(obj2)); 
deepCopy.details.age = 35; 
console.log(obj2.details.age); // ✅ Original remains unchanged (deep copy)


================================================

34. Can you provide an example of a complex React.js project you worked on and explain your role in its development?

In a recent project, I played a significant role in developing a complex React.js feature for a flight ticket booking system. 
One of the challenges involved resolving issues related to account setup. 
To tackle this, I utilized Postman to interact with multiple APIs and successfully unlock accounts, ensuring smooth user experience. 
I also documented this process for team reference, promoting efficiency and collaboration. Moreover, I have experience in managing weekly releases,
effectively addressing any backend blockers to maintain a seamless UI. 
his hands-on experience in addressing complex challenges showcases my ability to contribute effectively to React.js projects.

35. How do you ensure the scalability and performance optimization of React.js applications you work on?

In my React.js development work, I prioritize scalability and performance optimization by leveraging important tools and techniques. 
For instance, I implement the use of useMemo and useCallback hooks to efficiently memoize values and minimize recalculations. 
Additionally, I utilize code splitting and lazy loading to ensure that resources are loaded only when needed, enhancing the application's
overall performance. Moreover, I focus on optimizing assets and images to reduce load times. By strategically applying these methods, 
I have consistently improved the performance of React.js applications, ensuring a smooth and responsive user experience

36. In your opinion, what are the key differences between React.js functional components and class components, and when would you choose one over the other?

React.js provides two main types of components: functional components and class components. 
The key difference lies in their syntax and usage. 
Class components are defined as a class that extends the 'Component' class from React and uses lifecycle methods for actions like mounting, 
updating, and unmounting. On the other hand, functional components are implemented as plain JavaScript functions. 
With the introduction of hooks in React 16.8, functional components now support state management and side effects through hooks like useState, 
useEffect, useCallback, useRef, and useMemo. 
It's important to note that both types can be used effectively, but functional components are currently favored due to the simplicity and 
reusability offered by hooks. This allows for clearer and more concise code.

=======================================================================
Technical Round - 45 min to 1hr

1. ReactJS
2. JavaScript
3. CSS3
4. HTML5

ReactJS

1. Explain redux and its architecture

Redux is a state management library for JavaScript applications, often used with React to manage global state in a predictable way.

Redux Architecture:
Store – Holds the application’s state.

Action – A plain object that describes what happened (e.g., { type: 'INCREMENT' }).

Reducer – A pure function that takes the current state and an action, and returns a new state.

Dispatch – Sends actions to the store.

Subscriber – Components subscribe to the store to receive updates.

Data flow is unidirectional:
Component → Dispatch Action → Reducer → New State → UI Update

2. What is Virtual DOM and how does it work?

Virtual DOM is a lightweight copy of the real DOM. 
When the state changes, React creates a new Virtual DOM, compares it with the old one (diffing), and updates only 
the changed parts in the real DOM for better performance.

3. What is Reconciliation?

✅ Reconciliation – React compares Virtual DOM changes with the real DOM. 

4. Have you worked on class component or functional?

"Yes, I have experience working with both class and functional components in React. 
Initially, I used class components for state management and lifecycle methods, but with the introduction of hooks, 
I transitioned to functional components for their simplicity and reusability. 
Functional components, along with hooks like useState and useEffect, have allowed me to write cleaner, more maintainable code. 
While I can work with class components when needed, I primarily use functional components in newer projects to align with modern React practices.


5. what are hooks in react and why are they used?

Hooks in React are functions that let you use state and lifecycle features in functional components, without needing class components.

Why are they used?
Manage state: useState allows state management in functional components.

Side effects: useEffect handles data fetching, subscriptions, and other effects.

Performance optimization: useMemo and useCallback help prevent unnecessary re-renders.

Custom logic reuse: Custom hooks enable sharing logic across components.

6. how do you setup routing in react application?

Use React Router for routing:

Install it: npm install react-router-dom

Wrap the app in <BrowserRouter>

Use <Routes> and <Route> to define paths

Use <Link> for navigation

7. What technique can be used to optimize react application?

Optimizing a React app: 
Use React.memo, useCallback, and useMemo to prevent unnecessary re-renders. 
Apply lazy loading, code splitting, and virtualization for efficient rendering. 
Optimize state management, minimize useEffect dependencies, and use SSR/SSG for faster load times.

javascript
---------------
1. What is closure in Javascript? what is lexical scope?

Closure allows a function to remember and access its parent’s variables even after execution.

Lexical scope determines variable accessibility based on where functions are declared in the code.

2. what is hoisting in javascript? 

Hoisting is JavaScript's behavior of moving variable and function declarations to the top of their scope before execution. 

Functions are fully hoisted, while var variables are hoisted but remain undefined until assigned. 
let and const are hoisted but inaccessible until initialized.

3. what are callback, promises and async-await?

Callback: A function passed as an argument to another function, executed later. 

Promise: An object representing a pending, fulfilled, or rejected asynchronous operation. 

Async/Await: A way to write asynchronous code more cleanly, making it look synchronous. 

All three help manage async tasks like API calls and file handling.


4. what are the ES6 feature?

ES6 features:

Let & Const: Block-scoped variables.

Arrow Functions: Shorter function syntax (() =>).

Template Literals: String interpolation (${}) and multi-line strings.

Destructuring: Unpacking values from arrays/objects.

Default Parameters: Default values for function parameters.

Rest & Spread: Handle arrays/objects (...).

Classes: OOP syntax for creating classes.

Modules: import and export for modular code.

Promises: Asynchronous operations handling.

Iterators & Generators: Custom iteration with for...of and yield.



5. What is Event Loops in JS?

Event Loop in JavaScript is a mechanism that handles asynchronous operations. 
It allows the JavaScript engine to execute non-blocking code (like I/O operations) by using the call stack, callback queue, and event queue.

Call Stack: Where the functions are executed.

Callback Queue: Stores the callback functions that need to be executed after the call stack is clear.

Event Loop: Continuously checks if the call stack is empty, and if so, moves the first event from the callback queue to the stack for execution.

6. What is ES6 Array methods - map(), filter()

map(): Creates a new array by applying a function to each element of the original array.

const arr = [1, 2, 3];
const newArr = arr.map(x => x * 2); // [2, 4, 6]

filter(): Creates a new array with all elements that pass the condition in the provided function.

const arr = [1, 2, 3, 4];
const evenArr = arr.filter(x => x % 2 === 0); // [2, 4]




CSS3:

1. Explain the Box Model in CSS?

The CSS Box Model describes how elements are structured on a page. It includes:

Content – The actual text or image.

Padding – Space around the content.

Border – Wraps around the padding.

Margin – Space outside the border, separating elements.

2. What is difference between position Absolute & Relative?

position: relative moves an element relative to its normal position.
position: absolute removes the element from the normal flow and positions it relative to the nearest positioned ancestor.

3. What is the difference between rem and px?

px is an absolute unit — it defines a fixed size in pixels.
rem is a relative unit — it scales based on the root element’s (<html>) font size.

Example: If root font size is 16px, then 1rem = 16px.

4. What is Flex box?

Flexbox is a CSS layout model that makes it easy to align, space, and distribute items in a container, even when their size is unknown.

It uses properties like display: flex, justify-content, align-items, and flex-direction to create responsive layouts.

5. What is Grid Layout?

CSS Grid Layout is a 2D layout system used to design web pages in rows and columns.

It allows precise control over placement using properties like display: grid, grid-template-columns, grid-template-rows, and grid-gap.


HTML5:

1. What is Semantic Elements in HTML?
Semantic elements in HTML clearly describe their meaning to both the browser and developer.
Examples include <article>, <section>, <header>, and <footer>. They improve readability, accessibility, and SEO.

2. What is purpose of meta tag in HTML?

The meta tag in HTML provides metadata about the web page, such as character encoding, author, description, and 
viewport settings. It's mainly used for SEO and browser behavior control

3. What is block level and inline element?

Block-level elements take up the full width and start on a new line (e.g., <div>, <p>, <h1>).
Inline elements take up only as much width as needed and do not start on a new line (e.g., <span>, <a>, <strong>).


4. What is local storage vs Session Storage
Local Storage stores data with no expiration time — it persists even after the browser is closed.
Session Storage stores data only for the duration of the page session — it clears when the tab or browser is closed.

==========================================================================================================================

technical interview questions
-----------------------------------------

1. tell me about yourself?

2. which version of react.js are using? React v18.2.0

3. what is async await?
async and await are JavaScript keywords used to handle asynchronous operations in a cleaner, more readable way compared 
to traditional Promises and callbacks

"async/await is a syntax in JavaScript that makes it easier to work with Promises. 
async makes a function return a Promise, and await pauses execution until the Promise resolves, 
 asynchronous code to be written in a more readable, synchronous-like way."

4.  what is synchronous vs asychronous?

Synchronous code runs one task at a time, blocking the next task until the current one finishes.
Asynchronous code allows multiple tasks to run without waiting—like handling network requests—so the 
program stays responsive.

5. how to call multiple api calls simunatenously?
To make multiple API calls at the same time, I use Promise.all(). 
It takes an array of Promises and waits until all of them are resolved or any one fails.

async function fetchAllData() {
  const [userData, postsData] = await Promise.all([
    fetch('/api/user'),
    fetch('/api/posts')
  ]);

  const user = await userData.json();
  const posts = await postsData.json();

  console.log(user, posts);
}

// This runs both API calls at the same time and waits for both to complete.

6. what is controlled and uncontrolled components?

In React, controlled components are form elements whose values are managed by React state. 
Uncontrolled components manage their own state internally using the DOM, often accessed via ref.

Controlled: React is the single source of truth.

Uncontrolled: DOM handles the form data.

7. what is Debouncing ?

Debouncing is a technique used to limit how often a function is called.
It ensures the function runs only after a specified delay once the last event (like typing or scrolling) has stopped. 
It’s commonly used to optimize performance in search inputs, resize, or scroll events.

8. What is useEffect hook? How Does useEffect Work?

The useEffect hook in React is used to handle side effects in functional components, like data fetching, 
subscriptions, or manually changing the DOM. It runs after the component renders.

✅ How useEffect Works:


useEffect(() => {
  // Side effect logic here (e.g., API call)

  return () => {
    // Optional cleanup (e.g., clear timer, unsubscribe)
  };
}, [dependencies]);
The first argument is a function with your side effect logic.

The second argument is a dependency array that controls when the effect runs.



9. did you work on custom hooks?
Yes, I’ve worked with custom hooks in React to encapsulate reusable logic and keep components clean. 
For example, I created a custom hook for form handling, another for API data fetching with loading and error states, 
and one to manage debounced input values. This helped maintain separation of concerns and made my code more modular 
and testable.

10. how to make api call without useEffect?

You can make an API call without using useEffect by triggering it through user actions like a button click,
form submission, or any other event handler.

11. What is promise.All() and race?

Promise.all(): Waits for all Promises to resolve or for any to reject.

Promise.race(): Resolves or rejects as soon as one Promise resolves or rejects.


12. How do you integrate 2 API in front end with useEffect?
To integrate two APIs in the frontend using useEffect, 
you can either call them simultaneously with Promise.all() or sequentially.

Simultaneous: Both APIs are called in parallel.

Sequential: One API is called after the other.

13. How Do Uncontrolled Components Work?
Uncontrolled components in React manage their own state via the DOM, not React state. You access the values using refs.


14. redux architecture?

Redux architecture consists of three key parts:

Store: Holds the entire application state.

Actions: Plain objects that describe what happened.

Reducers: Functions that update the state based on the action.

Data Flow:
Actions are dispatched.

Reducers process the action and return a new state.

Store updates and re-renders subscribed components.


15. what is == vs ===? Which One Should You Use?

== (Loose Equality): Compares values after type coercion (converts the types before comparing).

=== (Strict Equality): Compares both value and type without type coercion.

Always use === for strict equality to avoid unexpected results from type coercion.

== should be avoided unless you specifically want type coercion.

16. can you explain your implementation

17. have you worked as a LEAD?


18. what is return and commit in JSX?

return in JSX is used to return the JSX that represents the UI in React components.

Example:

function MyComponent() {
  return <div>Hello</div>;
}
commit is not a standard React/JSX concept. 
It might refer to operations in third-party libraries or custom implementations, often related to finalizing changes 
or state updates.

19. What is map()? and reduce()?


map(): Creates a new array by applying a function to each element of the original array.

[1, 2, 3].map(num => num * 2); // [2, 4, 6]

reduce(): Accumulates a single value by applying a function to each element, with an accumulator.

[1, 2, 3].reduce((acc, num) => acc + num, 0); // 6


20. what is the output of map()?

The output of map() is a new array with transformed elements based on the function provided.

Example:
[1, 2, 3].map(num => num * 2); // [2, 4, 6]

====================================================================

30 minute interview

Senior React.js Developer Interview Question and Answers.

1. Tell me about yourself?


2. React Hooks: 
Hooks are functions that enable functional components to manage state and lifecycle features, 
providing a more concise and expressive way to handle component logic.

3. What are the popular hooks in react and explain it's usage?

useState: Manages state in functional components.
useEffect: Manages side effects in functional components.
useContext: Consumes context in functional components.
useReducer: Manage state with a reducer function, For More complex state management.
useRef: Accesses DOM elements or stores mutable values.
useCallback: performance improvement usecase
useMemo: performance improvement usecase.

4. How can you Optimize Performance in React application?
1. Memoization with useMemo and useCallback:  Use this hooks to memoize values and, reducing unnecessary recalculations.
2. Optimizing Renders with React.Fragment: Use it to avoid unnecessary wrapper elements that could cause additional DOM nodes.
3. Lazy loading with React.lazy: Use it to load components lazily, reducing the intial bundle size and imporving intial loading performance.
4. Code splitting: Employ code splitting to divide your application into smaller chunks that are loaded on demand, improving initial load times.
5. Optimizing Images and Assets:  Compress and optimize images, use responsive images and leverage lazy loading for images to reduce network and rendering overhead.


5.  Difference between virtual DOM and real DOM?
Suppose line of code is changed , processing is done on particular line. 
It will process the whole code in real DOM. Virtual DOM is faster.

6. Redux is a predictable state container for JavaScript applications. 
It helps to you write applications, run in different environments and easy to test. 
And simply we called as Redux is a state management tool.
Components in redux
Actions -->Input Parameters Ex: Deposit and Withdraw money from ATM
Store --> Main Server
Reducers --> Business Logic
Dispatch --> Request
Subscribe --> Response
State --> Store Component Data

7. What is state management in react application? 3rd party module, with redux.
Redux? We have redux thux, redux saga.
What is redux thunx, redux saga? Inorder to manipulate the store Actions(request, response).
Redux thunx is an outdated library.
Saga is Advanced library.

Why Saga? In sagas debouncing is available by default.

8. Explain React lifecycle methods?

React component lifecycle has three categories – Mounting, Updating and Unmounting.
Mounting – Birth of your component
Update – Growth of your component
Unmount – Death of your component

React Component LifeCycle Hooks

        1. constructor
        2. componentWillMount()
        3. render()
        4. componentDidMount()
        5. componentWillReceiveProps()
        6. shouldComponentUpdate()

        // component kill methods

        7. componentWillUpdate()
        8. componentDidUpdate()
        9. componentWillUnmount()

Recently Added LifeCycle Hooks

Context API, useEffect, useState --- Newly added version by version

Explanation:

# Constructor()

        constructor will execute at booting time of component --constructor will execute only once
        Define state in constructor

# componentWillMount()

        componentWillMount() will execute after constructor
        componentWillMount() will execute only once
        in general we will do the initial modifications in state
        in general we will set global parameters like width, height

# render()

        after componentWillMount() automatically render() function will execute
        render() is mandatory lifecycle hook(main lifecycle hook)
        in general, we will place presentation logic in render()
        when ever change detected in state or props automatically this lifecycle hooks will execute

# componentDidMount()

        after render function immediately componentDidMount() life cycle hook will execute
        in general we will make asynchronous calls in ComponentWillMount()
        this is recommended state to change the state of component

# componentWillReceiveProps()

        when component will receive props from redux

# shouldComponentUpdate()

        if we want to update the state return "true" else "false"

# UNSAFE_componentWillUpdate()

        death method --> perform cleanup operations

# componentDidUpdate()

        if we integrate any third party UI elements
        plugin logic will write here

# componentWillUnmount()

        Before killing the component componentWillUnmount is executed.
        death method --> perform cleanup operations


9. Call() -- if we want to create second memory location will interact with 1st memory location.

Apply – if we want to pass array instead of independent parameter

Bind() - merge memory location 1 and memory location 2 -->merge 2 memory locations-->new memory location.

What is the USE? Call function advanced function APPLY, call and apply advanced version is bind().
Purpose is same. Call, bind, apply –used to access 2 objects in different memory location

10. What is the current ES version? ES6 -2015, ES9, JS24

11. What are different positions in CSS ?
The position property specifies the type of positioning method used for an element.

There are five different position values:

static: HTML elements are positioned static by default.

relative: An element with position: relative; is positioned relative to its normal position.

fixed: An element with position: fixed; is positioned relative to the viewport, which means it always stays in the same place even if the page is scrolled. 
The top, right, bottom, and left properties are used to position the element.

absolute: An element with position: absolute; is positioned relative to the nearest positioned ancestor (instead of positioned relative to the viewport, like fixed).

sticky: An element with position: sticky; is positioned based on the user's scroll position.


12. What is shallow copy and deep copy? 

A shallow copy creates a new object with references to the same memory locations as the original object for nested properties. 
This means changes to nested objects in the copy will affect the original object.

javascript example: 
const originalObject = { a: 1, b: { c: 2 } };
const shallowCopy = { ...originalObject };

shallowCopy.b.c = 3;
console.log(originalObject.b.c); // Output: 3

Deep Copy
A deep copy creates a new object with new memory locations for all nested properties, ensuring changes to the copy don't affect the original object.

JavaScript Example:

javascript
const originalObject = { a: 1, b: { c: 2 } };
const deepCopy = JSON.parse(JSON.stringify(originalObject));

deepCopy.b.c = 3;
console.log(originalObject.b.c); // Output: 2

===============================================================================================

First Round: 30 minute React and Javascript.

1. current Project?

2. advantages of react?
    * Simple to build Single Page Application(by using Components - component based architecture).
    * React is cross platform and open source(Free to use)
    * Lightweight and very fast(Virtual DOM)
    * Large Community and Ecosystem.
    * Testing is easy.

3. hooks? some examples useState, useEffect?

    * React Hooks are inbuilt functions provided by React that allow functional components to useState and lifecycle features.
    * Before Hooks, class components lifecycle methods were used to maintain state in React Applications.
    * To use React hook first we first have to import it from React Library.

The useState hook enables functional components to manage state.
useState() working: useState() function accept the initial state value as the parameter and returns an array with 2 elements:
1. The first element is the current state value(count in this code).
2. Second element is the function that is used to update the state(setCount in this code).
The concept of assign array elements to individual variables is called array destructing.

The useEffect Hook in React is used to perform side effects in functional components.
For example, data fetching from API, subscriptions or any other operation that needs to be performed after the component has been rendered.

4. what is redux?

//state management(centralized store)
Redux is a predicatable state container for JavaScript apps. 
Redux acts as centralized store for state management in your application.
Advantages:
Single Source of Truth: The State of the application is stored in a single object.
State is Read-Only: The only way to change the state is to emit an action, an object describing what happened.
Changes are made with Pure Functions: Reducers are pure functions that take the previous state and an action, return the next state.

5. what is synthetic event?

a synthetic event is a cross-browser wrapper around the browser's native event. 
It combines the behavior of supported events of different browsers into one API, ensuring that events work identically across all browsers.

6. Event delegation?
Event delegation is a technique in JavaScript where a single event listener is attached to a parent element to handle events for
all of its child elements. 
Instead of attaching individual event listeners to each child, the parent element "delegates" the handling of events to its children. 
This approach leverages event bubbling, where an event on a child element propagates up the DOM tree to its parent elements. 


7. Why is javascript is synchronous not asynchronous?
JavaScript is primarily synchronous, running one piece of code at a time. 
However, it can handle asynchronous tasks using callbacks, promises, and async/await. 
This allows JavaScript to remain responsive by doing other work while waiting for time-consuming operations to finish.

8. What is the current ES version? ES6 -2015, ES9, JS24

9. object methods?
object.keys
object.values
object.freeze - we can't modify or delete from object
object.seal - we can modify but can't delete or add.

10. how to add properties to object?
object.assign()

11. suppose car has color, model and features, add some more properties of basic car?

12. create a object in javascript in jsfiddle?

const city ={
    name: 'austin',
    population: '10million',
}
city.street = '';

13. object.prototype?

14. coding question:
const fruits = [{name: 'apples', quantity: 500},
{name: 'bananas', quantity: 500},
{name: 'oranges', quantity: 150},
{name: 'kiwi', quantity: 150}];

show output: [[apples, bananas], [oranges, kiwi]];


//hint: use reduce

15. how browser knows javascript? JavaScript is preinstalle in browser.
if you write in typescript? it will convert the typescript to javascript.

use TS compiler

16. hoisting?

Hoisting is a behavior in JavaScript where variable and function declarations are moved to the top of their respective scopes during 
compilation phase, before the code is executed. This means that regardless of where variables and functions are declared in the code, 
they are treated as if they are declared at the beginning of their scope.

example:
console.log(x); //output: undefined
var x = 5;
console.log(x); //output: 5

the declaration of x is hoisted to the top, but not its initialization. That's why the first `console.log outputs undefined.

let and const declarations are hoisted but not initialized. This leads to a "temporal dead zone" where accessing the variable before its declaration results in a ReferenceError.

console.log(y);
// throws ReferenceError: Cannot access 'y' before "initialization"
let y = 10;



17. async/ await

The purpose of async/await is to simplify the syntax for working with Promises, making asynchronous code easier to write and read. 
It allows you to write asynchronous code that looks and behaves more like synchronous code.

// function that returns a promise
function fetchData() {
    return new Promise((resolve)=>{
        setTimeout(()=> resolve("data fetched"), 2000);
    });
}

// using async/await
async function getData() {
    console.log("fetching data...");
    const result = await fetchData();
    console.log(result);
    console.log("Data processing complete");
}

getData();

// output:
fetching data...
data fetched
Data processing complete

18. event bubbling? event capturing?

DOM elements are HTML Element. Parent , Child, Subchild.

Click Subchild -->Subchild, Child, Parent will execute.

The Events are propagating from down to top is called Event Bubbling.


What is Event Capturing? If I click parent only parent will execute. If I click child -->parent, child will execute. 
Propagation of Events from top to bottom is called Event Capturing.

React.js interview

19. what total experience in react.js till now? 12+

20. Which redux? redux-Toolkit:

Redux is a predicatable state container for JavaScript apps. Redux acts as centralized store for state management in your application.

Redux Toolkit is an offical, opinionated toolset for efficient Redux development.
It simplifies store setup, reduces boilerpate, and includes useful tools like createSlice and createAsyncThunk.

import {configureStore} from '@reduxjs/toolkit'; //import
const store = configureStore({
    reducer:{
        //pass all reducers
    },
});

export default store;

===============================================================================

Interview Question and answers

1. Tell me about yourself.

2. Which version of react? v16.8

3. How to optimize performance in react ?

1. Memoization with useMemo and useCallback:  Use this hooks to memoize values and, reducing unnecessary recalculations.
2. Optimizing Renders with React.Fragment: Use it to avoid unnecessary wrapper elements that could cause additional DOM nodes.
3. Lazy loading with React.lazy: Use it to load components lazily, reducing the intial bundle size and imporving intial loading performance.
4. Code splitting: Employ code splitting to divide your application into smaller chunks that are loaded on demand, improving initial load times.
5. Optimizing Images and Assets:  Compress and optimize images, use responsive images and leverage lazy loading for images to reduce network and rendering overhead.


4. What is difference between Promise.all() and race?

Promise.all() waits for all promises to settle (either resolve or reject), and resolves with an array of all resolved values or rejects as soon as one promise rejects.

Promise.race() resolves or rejects as soon as the first promise settles (either resolves or rejects).

5. difference between useMemo and useCallback?

Key Differences:

    useMemo: Memoizes the result of a computation (value). It helps with performance optimization by avoiding recalculating expensive values.

    useCallback: Memoizes the function itself, ensuring the function reference remains the same between renders unless its dependencies change. 
    It's mostly useful when passing functions as props to avoid unnecessary re-renders in child components.

6. Have you used async/await? use?

async: Declares a function that will always return a Promise.

await: Pauses the execution of the async function until the Promise resolves or rejects.

7. What are hooks in react? use?

useState: Manages state in functional components.
useEffect: Manages side effects in functional components.
useContext: Consumes context in functional components.
useReducer: Manage state with a reducer function, For More complex state management.
useRef: Accesses DOM elements or stores mutable values.
useCallback: performance improvement usecase
useMemo: performance improvement usecase.

8. did you work on custom hooks?

Custom Hooks in React are JavaScript functions that allow you to reuse stateful logic across multiple components.
They enable you to extract and share common logic without repeating code, promoting code reusability and separaration concerns.

c1, c2, c3, c4, c5--> one custom hooks --> state
Advantages:
Code Reusability: Custom hooks allow you to reuse stateful logic without duplicating code.
Separation of Concerns: They help spearate the logic from the component's structure, making the code more modular and easier to maintain.
Cleaner Code: By Moving common logic into custom hooks, components become cleaner and more focused on their core responsibilites.

9. Can we useHelp() hook instead of custom hook?

If useHelp() is a custom hook you've created or imported, then yes, you can use it just like any other hook.

Custom hooks don't replace built-in hooks; they are for organizing reusable logic. You can still use built-in hooks inside your custom hooks if needed.

10. what is callback?

Passing "one function" to "another function" as an argument called as "CallBack"

11. what is callback hell?

Callback hell" refers to a situation in programming where multiple asynchronous operations are handled using nested callback functions,
creating a complex and difficult-to-read code structure, often resembling a pyramid shape; 
to avoid it, use techniques like Promises and the async/await syntax to manage asynchronous operations in a more linear fashion,
making your code cleaner and easier to maintain. 

12. have you worked on NodeJS?

Node.js is commonly used for backend development, APIs, real-time applications (like chat apps), and more. 
It leverages non-blocking, event-driven architecture, making it ideal for I/O-heavy tasks like handling HTTP requests, reading files, and querying databases.

I can help with many aspects of Node.js development, including:

    Creating web servers using frameworks like Express.js.

    Working with databases (like MongoDB, MySQL, PostgreSQL) through libraries like mongoose or sequelize.

    Building APIs (RESTful APIs, GraphQL, etc.).

    Managing asynchronous operations (with callbacks, promises, and async/await).

    Implementing middleware for routing and error handling.

    Integrating third-party services (like payment gateways, email services, etc.).

    Optimizing performance (using clustering, worker threads, etc.).

    Deploying Node.js applications (on cloud platforms like AWS, Heroku, etc.).

13. difference between fetch and axios module?

fetch is a built-in JavaScript API that returns a Promise. It is native to the browser and doesn't require installing any additional libraries.

axios is a third-party library that also returns a Promise. It needs to be installed via npm or yarn (e.g., npm install axios).

Fetch Example:

fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));

Axios Example:

axios.get('https://api.example.com/data')
  .then(response => console.log(response.data))
  .catch(error => console.error('Error:', error));


14. call api in react syntax?

axios.get('https://api.example.com/data')
  .then(response => console.log(response.data))
  .catch(error => console.error('Error:', error));

15. what is hoisting? explain with example?

console.log(a); // Uncaught ReferenceError: a is not defined
let a; 

console.log(a); // Uncaught ReferenceError: a is not defined
let a = 10;

Hoisting is a behavior in JavaScript where variable and function declarations are moved to the top of their respective scopes during the compilation phase, before the code is executed. 
This means that regardless of where variables and functions are declared in the code, they are treated as if they are declared at the beginning of their scope.

example:
console.log(x); //output: undefined
var x = 5;
console.log(x); //output: 5

the declaration of x is hoisted to the top, but not its initialization. That's why the first `console.log outputs undefined.

let and const declarations are hoisted but not initialized. This leads to a "temporal dead zone" where accessing the variable before its declaration results in a ReferenceError.

console.log(y);
// throws ReferenceError: Cannot access 'y' before "initialization"
let y = 10;


16. What is promise?

 - Promises Establishes the communication between "producer" and "consumer".
 
        - Promises also called as "special javascript objects".
 
        - we will create Promises by using "Promise" class constructor.
 
        - Promises have 3 states
 
            1) success  (resolve)
 
            2) error    (reject)
 
            3) pending
 
        - we will consume promises by using "then()"

/*
    let promise1 = new Promise((resolve,reject)=>{
        resolve("tomorrow i will discuss async & await keywords");
    });
    promise1.then((posRes)=>{
        console.log(posRes);
    },(errRes)=>{
        console.log(errRes);
    });     //tomorrow i will discuss async & await keywords
*/

17. What is synchronous and asynchronous calls?

Synchronous calls block the program until the current task finishes. Everything happens in sequence.

Asynchronous calls allow the program to continue executing while waiting for a task to complete, preventing it from freezing or being blocked.

18. What operations did you perform in NodeJS?

    HTTP Server: Set up basic web servers to handle requests and responses.

    REST APIs: Created APIs for handling CRUD operations using Express.

    File Operations: Used the fs module to read, write, and manipulate files.

    Database Integration: Worked with databases (e.g., MongoDB) using libraries like Mongoose.

    Event-driven: Utilized the EventEmitter for event-driven programming.

    Asynchronous Programming: Managed asynchronous operations using Promises and async/await.

    Middleware: Built custom middleware in Express for additional functionality (e.g., logging, authentication).

Node.js offers a robust environment for developing scalable, event-driven applications and handling backend services, APIs, and tasks efficiently.

19. callback hell resolve?

Callback Hell can be mitigated by:

    Modularizing code: Break down tasks into smaller functions.

    Using Promises: Chain asynchronous operations and handle errors in a clean way.

    Using Async/Await: Write asynchronous code that looks synchronous, improving readability.

    Using Libraries like Async.js: Manage complex flows in a more elegant and concise way.

    Using Event Emitters: For managing more complex workflows that involve multiple events.

The async/await approach is generally the most modern and readable method, and it resolves the deep nesting of callbacks effectively, improving code quality and maintainability.

20. What is a closure in JavaScript?

    - if any inner function holding the outer function data, then such scenario called as closure.

21. can we write application in redux instead of redux-saga?

Yes, you can write applications using Redux without using Redux-Saga. Redux itself is a state management library, 
while Redux-Saga is a middleware used for handling side effects (like async actions such as fetching data from an API, interacting with external services, etc.).

22. what is difference redux, redux-thunk, redux-saga?

Redux is for managing the state of your application.

Redux-Thunk is a simple middleware for managing simple async logic like API calls or timeouts.

Redux-Saga is a middleware that handles complex side effects using generator functions, making it ideal for handling advanced async logic
(e.g., canceling tasks, running multiple tasks in parallel, and managing retries).

23. explain how redux architecture works? example?

Redux Data Flow

    User Interaction or Events trigger an action.

    The action is sent to the store using the dispatch function.

    The store forwards the action to the appropriate reducer.

    The reducer computes a new state based on the action.

    The store updates the state with the new value.

    The updated state can be accessed by React components or any part of the app.

This process follows the unidirectional data flow in Redux, where actions trigger state updates, and the components re-render based on the updated state.

24. what is react 19 features?

The New Additional Hooks in React 19:-

1. useFormStatus
-Tracks form submission status dynamically.
-Eliminates manual state tracking for pending operations.

2. useActionState
-Combines form actions and states into one seamless hook.
- Perfect for server-side rendered applications.

3. useOptimistic
-Supports optimistic Ul updates for async operations.
- Makes rollbacks smooth if operations fail.

4. use
-Brings promises and async context handling directly into components.
-Enhances Suspense for better async rendering.

25. what is useRef() hook?

The useRef hook is used to access and interact with DOM elements directly and to persist mutable values across renders without causing re-renders.



26. useLayoutEffect? useLayoutEffect fires before the browser repaints the screen. You can measure layout here.

useLayoutEffect: Synchornous Side effects.

27. what is synchronous vs asynchronous call?

Synchronous Call:

    A synchronous call means that the code is executed in a sequential, blocking manner. 
    The program executes each statement one after another, waiting for the previous one to finish before moving on to the next.

    In other words, each operation must complete before the next one begins.

Asynchronous Call:

    An asynchronous call allows certain tasks to run in the background while the program continues executing other code. 
    It doesn't block the rest of the program, and the operation may complete at a later time.

    Common asynchronous operations include fetching data from an API, setTimeout, Promises, or async/await syntax.


React

performance opt

Javascript



=========================================